<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清风轩</title>
  <subtitle>清风轩居 - 引仙阁</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xovel.cn/"/>
  <updated>2018-05-24T13:21:48.054Z</updated>
  <id>https://xovel.cn/</id>
  
  <author>
    <name>xovel</name>
    <email>xovel@vip.qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6 模块</title>
    <link href="https://xovel.cn/article/es6-modules.html"/>
    <id>https://xovel.cn/article/es6-modules.html</id>
    <published>2018-05-24T09:54:29.000Z</published>
    <updated>2018-05-24T13:21:48.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>阅读本文需要有一定的 ES6 基础。</p>
</blockquote>
<p>ES6 模块是 ES6 中的一个非常重要的特性，它收集了多年来各种模块化的优点，解决了其间的差异化，并期望能最终形成一个大家共同遵守的规范。</p>
<blockquote>
<p>关于 JS 的模块化历程，可以参考本文后面的<a href="https://appendto.com/2016/06/the-short-history-of-javascript-module-loaders/" target="_blank" rel="noopener">参考资料</a>。</p>
</blockquote>
<p>本文从 <code>import</code> 和 <code>export</code> 两部分对 ES6 模块做一个基础的介绍，这两部分内容也就是 ES6 模块的全部了。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>来看一组现有的 <code>import</code> 语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"module-name"</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码来自 MDN 上面关于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">import</a> 的介绍。</p>
</blockquote>
<p><code>import</code> 是模块导入语句的关键字，通过指定具体的导入方式，可以进行相应模块的导入操作。</p>
<p>以下是逐条说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入默认模块</span></span><br><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="comment">// 导入所有模块并指定一个新的名称，导入后的对象包含了所有具名模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="comment">// 导入指定模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="comment">// 导入指定的模块并指定一个新的名称，即直接进行重命名操作</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="comment">// 导入多个模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="comment">// 导入多个模块，并对其中的某一部分进行重命名</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="comment">// 同时导入默认模块和其他模块</span></span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="comment">// 同时导入模块模块，并将所有模块以新名称进行导入</span></span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="comment">// 直接引入模块，不导入任何东西</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"module-name"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p><code>export</code> 是模块导出语句的关键字，同样的，来看一组 <code>export</code> 的语法，代码来自 MDN 上面的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="noopener">export</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出指定模块</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125;;</span><br><span class="line"><span class="comment">// 导出指定模块，并进行重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> name1, variable2 <span class="keyword">as</span> name2, …, nameN &#125;;</span><br><span class="line"><span class="comment">// 导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1, name2, …, nameN; <span class="comment">// also var</span></span><br><span class="line"><span class="comment">// 导出变量，并对变量直接进行定义</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1 = …, name2 = …, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">FunctionName</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个表达式作为默认模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> expression;</span><br><span class="line"><span class="comment">// 导出匿名函数，类和生成器函数亦可</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="comment">// 导出具名函数，类和生成器函数亦可</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">name1</span>(<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="comment">// 将指定模块作为默认模块进行导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1 <span class="keyword">as</span> <span class="keyword">default</span>, … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从另一个模块提取所有模块进行导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> …;</span><br><span class="line"><span class="comment">// 从另一个模块提取指定模块进行导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="comment">// 从另一个模块提取指定的模块并进行重命名后再导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; import1 <span class="keyword">as</span> name1, import2 <span class="keyword">as</span> name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="comment">// 从另一个模块导出默认模块</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> …;</span><br></pre></td></tr></table></figure>
<h3 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h3><ol>
<li>在进行 <code>import</code> 的时候，<code>import { export } from &quot;module-name&quot;;</code> 中的 <code>{ export }</code> 语法并不等同于对象的解构，这是 <code>import</code> 专门的语法。</li><li><code>export</code> 和 <code>export default</code> 的区别是在后续进行引入的时候需要分别使用 <code>import { ... } from</code> 和 <code>import ... from</code> 进行操作。</li><li>作为默认模块进行导出时，匿名函数和具名函数在导出之后并无区分。</li><li>导出后的模块，如果存在变量，该变量对外是不可变的。可以通过模块内置的方法进行改变。</li></ol>
<hr>
<p>大体上就是这些内容了，ES6 的模块化给编程领域尤其是前端开发这一块，带来非常大的便利。</p>
<blockquote>
<p>由于市面上直接支持 ES6 模块的产品的覆盖率依然不够理想，所以需要通过一些转译工具进行转译之后再进行使用。这些工具中，首当其冲的就要数 <code>babel</code> 了。</p>
<blockquote>
<p>目前，本人主要工作是在进行微信小程序的开发，好在小程序现在的开发环境已经基本支持 <code>import</code> 和 <code>export</code> 语法（除了 <code>export ... from</code>），所以可以放心无忧的进行现代化 ES6 代码的编写了。目前使用原生代码进行微信小程序的编写，感觉良好。至于 <code>wepy</code> 和 <code>mpvue</code> 之类的前瞻框架，由于未进行全面使用，所以不做过多评述。</p>
</blockquote>
</blockquote>
<hr>
<p>在撰写本文的时候，参考了大量的资料，但是提笔的时候却又感觉很词穷，所以只是简单的做了一个代码层次的注释说明，更多的参考资料罗列如下，请诸君自行参阅。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="noopener">ECMAScript 6 modules: the final syntax</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">import - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="noopener">export - JavaScript | MDN</a></li><li><a href="https://blogs.windows.com/msedgedev/2016/05/17/es6-modules-and-beyond/" target="_blank" rel="noopener">Previewing ES6 Modules and more from ES2015, ES2016 and beyond</a></li><li><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/" target="_blank" rel="noopener">ES6 In Depth: Modules</a></li><li><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noopener">ES modules: A cartoon deep-dive</a></li><li><a href="http://exploringjs.com/es6/ch_modules.html#_modules" target="_blank" rel="noopener">Exploring ES6 - 16. Modules</a></li><li><a href="https://github.com/eslint/espree/pull/43" target="_blank" rel="noopener">eslint/espree - #43 - adds module import and export grammar</a></li><li><a href="https://github.com/tc39/proposal-export-default-from" target="_blank" rel="noopener">tc39/proposal-export-default-from</a></li><li><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">tc39/proposal-dynamic-import</a></li><li><a href="http://2ality.com/2015/07/es6-module-exports.html" target="_blank" rel="noopener">What do ES6 modules export?</a></li><li><a href="https://www.sitepoint.com/understanding-es6-modules/" target="_blank" rel="noopener">Understanding ES6 Modules</a></li><li><a href="http://www.commonjs.org/" target="_blank" rel="noopener">CommonJS</a></li><li><a href="http://jsmodules.io/" target="_blank" rel="noopener">JavaScript Modules</a></li><li><a href="https://developer.telerik.com/featured/choose-es6-modules-today/" target="_blank" rel="noopener">Choose ES6 modules Today!</a></li><li><a href="https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc" target="_blank" rel="noopener">JavaScript Modules: A Beginner’s Guide</a></li><li><a href="https://appendto.com/2016/06/the-short-history-of-javascript-module-loaders/" target="_blank" rel="noopener">History and Background of JavaScript Module Loaders</a></li><li><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="noopener">JavaScript Module Pattern: In-Depth</a></li></ul>
<p>&lt;本文完&gt;</p>
]]></content>
    
    <summary type="html">
    
      本文是对 ES6 模块化的简单介绍。
    
    </summary>
    
      <category term="WEB" scheme="https://xovel.cn/categories/web/"/>
    
      <category term="文档" scheme="https://xovel.cn/categories/web/docs/"/>
    
    
      <category term="javascript" scheme="https://xovel.cn/tags/javascript/"/>
    
      <category term="es6" scheme="https://xovel.cn/tags/es6/"/>
    
      <category term="module" scheme="https://xovel.cn/tags/module/"/>
    
      <category term="import" scheme="https://xovel.cn/tags/import/"/>
    
      <category term="export" scheme="https://xovel.cn/tags/export/"/>
    
  </entry>
  
  <entry>
    <title>使用 nginx</title>
    <link href="https://xovel.cn/article/use-nginx.html"/>
    <id>https://xovel.cn/article/use-nginx.html</id>
    <published>2018-03-26T01:07:00.000Z</published>
    <updated>2018-03-31T04:47:25.294Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://nginx.org/nginx.png" alt="nginx"></p>
<blockquote>
<p>本文根据个人日志中相关记录进行整理而成。</p>
<p>注意，这并不是一篇配置攻略或者是文档性质的，阅读时请不要以本篇文章描述的为主，请适当进行斟酌。</p>
</blockquote>
<p>导语中的文本来自于百度百科，不过根据官网的描述，<code>nginx</code> 是这样的一个东西：</p>
<blockquote>
<p>nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev.</p>
</blockquote>
<p>本文将一句个人日志项目中关于 <code>nginx</code> 的记载进行阐述。</p>
<p>最初，在去年 9 月份，我第一次记录了关于 <code>nginx</code> 的东西，是关于如何在 <code>nginx</code> 站点中开启文件目录的浏览：在 <code>location</code> 模块中使用 <code>autoindex on;</code> 指令即可。</p>
<p>然后没过多久，写了一篇关于开启指定域名访问的记录，即设置 <code>server_name</code> 指令。</p>
<p>在 12 月初，写了一篇重量级的文章，安装 <code>nginx</code>，这也是我第一次完全自己部署前端站点的一次尝试。</p>
<p><code>nginx</code> 的常规依赖：</p>
<ul>
<li><code>zlib</code>，用于开启 <code>gzip</code> 压缩。</li><li><code>pcre</code>，用于开启伪静态或者重定向。</li><li><code>openssh</code>，用于开启 <code>ssl</code>，或者换个说法，叫做 <code>https</code>。</li></ul>
<p>安装过程中需要 <code>gcc-c++</code> 运行库。</p>
<p>紧接着没多久，写了一篇如何配置 <code>nginx</code> 的日志，讲述了如何开启多配置文件模式，主要是 <code>include</code> 指令。顺便阐述了一下过滤非法域名访问的问题，<code>default_server</code> 关键字进行设置即可。</p>
<p>之后在一篇微信支付相关的记录中，提到了关于反向代理转发真实 IP 地址的方法。</p>
<p>过完年之后，由于等级保护评估测试相关的原因，针对前端全站开启了 <code>https</code> 模式。关键配置为 <code>listen 443 ssl;</code>，结合 <code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 进行相关文件的配置即可完成。</p>
<p>由于 <code>https</code> 的访问模式，页面不能直接使用 <code>http</code> 请求，于是针对之前提到的反向代理 <code>proxy_pass</code> 进行了再一次的阐述，并对负载均衡进行了说明。<code>nginx</code> 的负载均衡是一个非常强大的功能，主要依赖 <code>upstream</code> 来进行相关配置。</p>
<p>之后没多久，有需要页面重定向的需求，于是对 <code>rewrite</code> 指令做了简单的介绍。</p>
<p>因为某一次的服务器改版，转发 <code>https</code> 到 <code>http</code> 的时候，发现端口出现了稍稍的偏差。于是针对 <code>X-Forwarded-Proto</code> 之类的参数设置进行了相关的解释。</p>
<p>后来因个人项目，部署的时候想尝试一下路由的 <code>history</code> 模式，于是 <code>nginx</code> 的 <code>try_files</code> 指令被提上日程，但是目前我并没有进行日志记录。</p>
<p>至此，本人日志项目关于 <code>nginx</code> 的记录就回顾完毕，这大概也就是本篇文章的主要内容了。</p>
<p>另外，在阅读子项目中，曾经记录了一篇跟 <code>nginx</code> 密切相关的书籍《Nginx 开发从入门到精通》，该书是 <code>tengine</code> 开发团队主笔的。</p>
<hr>
<ul>
<li><a href="http://nginx.org/" target="_blank" rel="noopener">nginx 官网</a></li><li><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">nginx documentation</a></li><li><a href="http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html" target="_blank" rel="noopener">Module ngx_stream_upstream_module</a></li><li><a href="https://trac.nginx.org/nginx/browser/nginx/src/http/modules/ngx_http_proxy_module.c" target="_blank" rel="noopener">ngx_http_proxy_module.c in nginx/src/http/modules – nginx</a></li><li><a href="https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/" target="_blank" rel="noopener">If Is Evil | NGINX</a></li><li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">Nginx开发从入门到精通</a></li><li><a href="https://serverfault.com/questions/630413/nginx-apache-set-hsts-only-if-x-forwarded-proto-is-https" target="_blank" rel="noopener">Nginx/Apache: set HSTS only if X-Forwarded-Proto is https - Server Fault</a></li></ul>
]]></content>
    
    <summary type="html">
    
      Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器。
    
    </summary>
    
      <category term="随笔" scheme="https://xovel.cn/categories/essay/"/>
    
    
      <category term="nginx" scheme="https://xovel.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>node 下的微信公众号支付初探</title>
    <link href="https://xovel.cn/article/node-wxpay.html"/>
    <id>https://xovel.cn/article/node-wxpay.html</id>
    <published>2018-01-30T15:06:50.000Z</published>
    <updated>2018-01-31T02:53:28.513Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>那么，就直接开门见山呗。本篇博客根据个人日志记录整理而成。</p>
<p>项目地址：<a href="https://github.com/xovel/node-wxpay-test" target="_blank" rel="noopener">https://github.com/xovel/node-wxpay-test</a></p>
</blockquote>
<p>其实大部分的文档，微信官方开发文档里面都提供了，我们只需要按照其说明严格执行就可以达到目的。</p>
<p>注意，这里只讲述公众号支付相关的情形，其他的基本类似，本人未作深入实践，故此不敢多言。</p>
<p>这次的讲解，主要从四个方面进行说明：</p>
<ol>
<li>相关账户配置</li><li>后台的搭建</li><li>前端页面的展示</li><li>支付流程</li></ol>
<h3 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h3><p>首先，肯定是需要一个微信公众号的。公众号的性质需要满足开通商户号和微信支付，并且实际上已经开通好了。这次我用的账号是认证好了的服务号。</p>
<p>进入公众号设置界面，对相关的域名进行配置，本次调试，我使用的域名是 <code>z.hdk4.com</code>，故此在公众的管理页面的 <code>【设置】-【公众号设置】-【功能设置】</code> 中对 <code>业务域名</code>、<code>JS接口安全域名</code>、<code>网页授权域名</code> 全部进行了相应的设置。</p>
<blockquote>
<p>至于开发者的添加和公众号密钥和商户号密钥等数据的获取，属于入门级别，这里不再赘述。</p>
</blockquote>
<p>要做微信支付，需要事先对 <code>支付授权目录</code> 进行设置，在商户号管理页面就能够找得到，直接进行设置即可。注意这里是 <code>支付目录</code> 的设置，即浏览器访问下的 <code>location.pathname</code> 对应的访问路径，结尾必须以 <code>/</code> 结束且<strong>区分大小写</strong>。</p>
<h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>这一块最为重要也是核心所在，由于只是演示与测验，所以采用了简单粗暴的 <code>express</code> 来作为后台服务器。详情容后再禀。</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端页面相对来说简单一些，在引入微信的官方 <code>js</code>，即 <a href="http://res.wx.qq.com/open/js/jweixin-1.2.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.2.0.js</a> 之后，调用 <code>WeixinJSBridge</code> 的 API，发起 <code>getBrandWCPayRequest</code> 请求即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WeixinJSBridge.invoke(<span class="string">'getBrandWCPayRequest'</span>, &#123;</span><br><span class="line">  appId: data.appId,</span><br><span class="line">  timeStamp: data.timeStamp,</span><br><span class="line">  nonceStr: data.nonceStr,</span><br><span class="line">  package: data.package,</span><br><span class="line">  signType: data.signType,</span><br><span class="line">  paySign: data.paySign</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然，在这里之前，需要先获取用户的 <code>openid</code>。</p>
<p>当然，在获取 <code>openid</code> 之前，还需要获取一下用户的访问 <code>code</code>。</p>
<p>那么，这个访问的 <code>code</code> 如何获取呢？</p>
<p>根据微信开发文档提供的链接 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842</a>，我们先判断链接是否有 <code>code</code> 字段，如果没有则跳转到微信的链接去进行获取。获取到了之后再进行 <code>openid</code> 的获取。文档方面的信息这里不详细展开，直接上代码进行说明吧！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> code = getUrlParam(<span class="string">'code'</span>) || sessionStorage.code;</span><br><span class="line"><span class="keyword">var</span> openid = sessionStorage.openid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 openid 则尝试获取 code</span></span><br><span class="line"><span class="comment">// code 获取之后跳回原链接进行临时存储</span></span><br><span class="line"><span class="keyword">if</span> (!openid) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!code) &#123;</span><br><span class="line">    <span class="keyword">var</span> redirect_uri = <span class="built_in">encodeURIComponent</span>(<span class="string">'http://z.hdk4.com/d.html'</span>);</span><br><span class="line">    <span class="built_in">window</span>.location.replace(<span class="string">'https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxbce0a3daf503097c&amp;redirect_uri='</span> + redirect_uri + <span class="string">'&amp;response_type=code&amp;scope=snsapi_base&amp;state=7'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!sessionStorage.code) &#123;</span><br><span class="line">    sessionStorage.code = code;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(<span class="string">'http://z.hdk4.com/d.html'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几点说明：</p>
<ul>
<li><code>redirect_uri</code> 中的 <code>state=7</code> 是随便写的一个值。</li><li><code>window.location.replace</code> 用于直接替换，如果不想要替换效果，可以修改为 <code>window.location.href = &#39;...&#39;</code>。</li><li>采用 <code>sessionStorage</code> 进行数据的缓存。</li><li><code>getUrlParam</code> 为提取链接中的 <code>querystring</code>。</li><li><del>不要管 <code>yoda</code> 什么的了</del></li></ul>
<p>前端差不多能说的就这么多了。</p>
<h3 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h3><p>整个支付流程浓缩起来就是：</p>
<ol>
<li>获取 <code>code</code></li><li>获取 <code>openid</code></li><li>开始进行支付操作</li><li>后台发起预支付订单</li><li>后台将获取到的预支付信息返回给前端</li><li>前端尝试唤起微信支付</li><li>进行支付</li><li>前端/后台处理支付回调。是的，都进行处理。前端无所谓，后台必须处理，不然微信会发很多次请求。</li><li>支付完成</li><li>后续一些相关操作。由于本次只是演示与测验，就不做处理了。</li></ol>
<hr>
<p>现在来说一下核心的重点，即后台的相关逻辑处理与接口的设计。</p>
<h3 id="后台-1"><a href="#后台-1" class="headerlink" title="后台"></a>后台</h3><p>相关的库的引入与声明，这里就不赘述了。</p>
<h4 id="api-getopenid-接口"><a href="#api-getopenid-接口" class="headerlink" title="/api/getopenid 接口"></a><code>/api/getopenid</code> 接口</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 openid</span></span><br><span class="line">app.get(<span class="string">'/api/getopenid'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> code = req.query.code;</span><br><span class="line">  <span class="keyword">const</span> access_token_url = <span class="string">`https://api.weixin.qq.com/sns/oauth2/access_token?appid=<span class="subst">$&#123;config.app_id&#125;</span>&amp;secret=<span class="subst">$&#123;config.app_secret&#125;</span>&amp;code=<span class="subst">$&#123;code&#125;</span>&amp;grant_type=authorization_code`</span>;</span><br><span class="line"></span><br><span class="line">  request.post(&#123; <span class="attr">url</span>: access_token_url &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">    wFile(<span class="string">'openid'</span>, body);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      res.json(&#123; <span class="attr">error</span>: body &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (body.errcode === <span class="number">40029</span> ) &#123;</span><br><span class="line">        res.json(&#123; <span class="attr">error</span>: body &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        body = <span class="built_in">JSON</span>.parse(body);</span><br><span class="line">        res.json(&#123; <span class="attr">data</span>: body &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.json(&#123; <span class="attr">error</span>: <span class="number">-1</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>wFile</code> 是日志记录相关操作，可以无视。</p>
</blockquote>
<p>该接口是用来获取用户的 <code>openid</code> 的，要求的东西是 <code>code</code>，这个 <code>code</code> 就是上面前端花费一番周折得到的东西。</p>
<p>前端调用方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOpenId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sessionStorage.openid) &#123;</span><br><span class="line">      resolve(sessionStorage.openid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $.get(<span class="string">'/api/getopenid?code='</span> + sessionStorage.code).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = res.data;</span><br><span class="line">        <span class="keyword">if</span> (data &amp;&amp; data.openid) &#123;</span><br><span class="line">          sessionStorage.openid = data.openid;</span><br><span class="line">          resolve(data.openid)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>是的， <code>$</code> 就是大名鼎鼎的 <code>jQuery</code>。</li><li>采用了 <code>Promise</code> 对象。</li></ul>
<h4 id="api-unifiedorder-接口"><a href="#api-unifiedorder-接口" class="headerlink" title="/api/unifiedorder 接口"></a><code>/api/unifiedorder</code> 接口</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取微信支付的统一下单相关数据</span></span><br><span class="line">app.get(<span class="string">'/api/unifiedorder'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> openid = req.query.openid;</span><br><span class="line">  <span class="keyword">const</span> ip = getClientIp(req);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 商户订单号</span></span><br><span class="line">  <span class="keyword">const</span> out_trade_no = <span class="string">'test'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统一下单的相关参数</span></span><br><span class="line">  <span class="keyword">const</span> paramUnifiedOrder = &#123;</span><br><span class="line">    appid: config.app_id,</span><br><span class="line">    attach: <span class="string">'test'</span>,</span><br><span class="line">    body: <span class="string">'desc'</span>,</span><br><span class="line">    mch_id: config.mch_id,</span><br><span class="line">    nonce_str: createNonceStr(),</span><br><span class="line">    notify_url: config.notify_url, <span class="comment">// 微信付款后的回调地址</span></span><br><span class="line">    openid: openid,</span><br><span class="line">    out_trade_no: out_trade_no,</span><br><span class="line">    spbill_create_ip: ip,</span><br><span class="line">    total_fee: <span class="number">1</span>,</span><br><span class="line">    trade_type: <span class="string">'JSAPI'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 签名</span></span><br><span class="line">  paramUnifiedOrder.sign = getSign(paramUnifiedOrder);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求微信支付下单接口，获取预订单编号</span></span><br><span class="line">  request.post(&#123; <span class="attr">url</span>: <span class="string">'https://api.mch.weixin.qq.com/pay/unifiedorder'</span>, <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(getUnifiedOrderXml(paramUnifiedOrder)) &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">    wFile(<span class="string">'unifiedorder'</span>, body);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      res.json(&#123; <span class="attr">error</span>: body &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> prepay_id = <span class="string">''</span>; <span class="comment">// 预订单编号</span></span><br><span class="line">      <span class="comment">// 微信返回的数据为 xml 格式，需要进行解析</span></span><br><span class="line">      xml2jsparseString(body, &#123; <span class="attr">async</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">        prepay_id = result.xml.prepay_id[<span class="number">0</span>]; <span class="comment">// 获取预订单编号</span></span><br><span class="line">        <span class="keyword">const</span> paramWCPay = &#123;</span><br><span class="line">          appId: config.app_id,</span><br><span class="line">          timeStamp: <span class="built_in">parseInt</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() / <span class="number">1000</span>).toString(),</span><br><span class="line">          nonceStr: createNonceStr(),</span><br><span class="line">          package: <span class="string">'prepay_id='</span> + prepay_id,</span><br><span class="line">          signType: <span class="string">'MD5'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        paramWCPay.paySign = getSign(paramWCPay); <span class="comment">// 微信支付签名</span></span><br><span class="line">        res.json(&#123; <span class="attr">data</span>: paramWCPay &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.json(&#123; <span class="attr">error</span>: <span class="number">-1</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getClientIp</code> 是获取客户端真实 IP 地址的方法。</li><li><code>createNonceStr</code> 是生成随机串的方式，非常简单粗暴。</li><li><code>out_trade_no</code> 是商户自定义的订单号。</li><li><code>getUnifiedOrderXml</code> 是用来拼接发送给微信支付统一下单接口的数据，要 <code>xml</code> 格式的，所以就给一个封装。</li><li><code>xml2jsparseString</code> 是解析 <code>xml</code> 文件的库。微信支付统一下单接口返回的数据是 <code>xml</code> 格式的，需要进行相应的解码。</li><li><code>getSign</code> 是生成签名的方法。</li></ul>
<hr>
<p>如果不出意外，下单接口会返回一个 <code>xml</code> 数据，然后我们就可以提取到 <code>prepay_id</code> 这个核心的信息了。</p>
<h4 id="api-wxresponse-接口"><a href="#api-wxresponse-接口" class="headerlink" title="/api/wxresponse 接口"></a><code>/api/wxresponse</code> 接口</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理微信支付的回调</span></span><br><span class="line">app.post(<span class="string">'/api/wxresponse'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  wFile(<span class="string">'response'</span>, req.body);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> xmlData = req.body.xml;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (xmlData.sign === getSign(xmlData)) &#123;</span><br><span class="line">    ret = <span class="string">`&lt;xml&gt;</span></span><br><span class="line"><span class="string">  &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;</span></span><br><span class="line"><span class="string">  &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;</span></span><br><span class="line"><span class="string">&lt;/xml&gt;`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ret = <span class="string">`&lt;xml&gt;</span></span><br><span class="line"><span class="string">  &lt;return_code&gt;&lt;![CDATA[SIGNATRURE_ERROR]]&gt;&lt;/return_code&gt;</span></span><br><span class="line"><span class="string">  &lt;return_msg&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_msg&gt;</span></span><br><span class="line"><span class="string">&lt;/xml&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  res.send(ret);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>该接口是用来处理 <code>notify_url</code> 指定的回调链接的相关数据的，本次用的具体值就是 <a href="http://z.hdk4.com/api/wxresponse" target="_blank" rel="noopener">http://z.hdk4.com/api/wxresponse</a>。</p>
<p>如果不对该接口做回应，微信支付会一直发请求，直至系统判定失败。</p>
<blockquote>
<p>注意，使用 <code>express</code> 进行开发时，会收不到 <code>req.body</code>，采用以下方法进行解决即可：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'body-parser-xml'</span>)(bodyParser);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决微信支付通知回调数据</span></span><br><span class="line">app.use(bodyParser.xml(&#123;</span><br><span class="line">  limit: <span class="string">'1MB'</span>,   <span class="comment">// Reject payload bigger than 1 MB</span></span><br><span class="line">  xmlParseOptions: &#123;</span><br><span class="line">    normalize: <span class="literal">true</span>,     <span class="comment">// Trim whitespace inside text nodes</span></span><br><span class="line">    normalizeTags: <span class="literal">true</span>, <span class="comment">// Transform tags to lowercase</span></span><br><span class="line">    explicitArray: <span class="literal">false</span> <span class="comment">// Only put nodes in array if &gt;1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h4 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 签名算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSign</span>(<span class="params">paramSign</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 按 key 值的 ascii 排序</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(paramSign).sort();</span><br><span class="line">  <span class="keyword">const</span> temp = [];</span><br><span class="line">  keys.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (paramSign[v] &amp;&amp; v !== <span class="string">'sign'</span>) &#123;</span><br><span class="line">      temp.push(<span class="string">`<span class="subst">$&#123;v&#125;</span>=<span class="subst">$&#123;paramSign[v]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  temp.push(<span class="string">`key=<span class="subst">$&#123;config.mch_key&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret = temp.join(<span class="string">'&amp;'</span>);</span><br><span class="line">  <span class="comment">// 生成签名</span></span><br><span class="line">  <span class="keyword">return</span> crypto.createHash(<span class="string">'md5'</span>).update(ret, <span class="string">'utf8'</span>).digest(<span class="string">'hex'</span>).toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常<del>简单粗暴</del>的算法，嗯，如上所示。如果是其他语言，在生成 <code>MD5</code> 值的时候方法可能会有所不同，使用对应的方法即可。</p>
<h4 id="随机字符串方法"><a href="#随机字符串方法" class="headerlink" title="随机字符串方法"></a>随机字符串方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNonceStr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">2</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>是的，这一条是滥竽充数的</del>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_4" target="_blank" rel="noopener">获取openid</a></li><li><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">微信网页授权</a></li><li><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6" target="_blank" rel="noopener">微信内H5调起支付</a></li><li><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3" target="_blank" rel="noopener">签名算法</a></li><li><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1" target="_blank" rel="noopener">统一下单</a></li><li><a href="https://github.com/wxpay/WXPay-SDK-Node.js" target="_blank" rel="noopener">wxpay/WXPay-SDK-Node.js</a></li><li><a href="https://gitee.com/anziguoer/wechatPay" target="_blank" rel="noopener">nodejs 微信公众号支付开发</a>，<em>大部分代码参考于此</em>。</li><li><a href="https://www.cnblogs.com/yimiyan/p/5603657.html" target="_blank" rel="noopener">微信公众号支付开发全过程 –JAVA</a></li><li><a href="http://blog.csdn.net/aofavx/article/details/52220394" target="_blank" rel="noopener">微信公众号支付详细步骤(整理)</a></li><li><a href="https://segmentfault.com/a/1190000005797170" target="_blank" rel="noopener">Nginx向ExpressJS转发真实IP地址</a></li><li><a href="https://www.jianshu.com/p/0496ef49b2a5" target="_blank" rel="noopener">Nodejs 部署到阿里云全过程</a></li><li><a href="http://www.expressjs.com.cn/starter/static-files.html" target="_blank" rel="noopener">利用 Express 托管静态文件</a></li><li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass" target="_blank" rel="noopener">proxy_pass</a></li></ul>
]]></content>
    
    <summary type="html">
    
      本文记录一下关于 node/express 下的微信公众号支付测试小 demo 的开发过程。
    
    </summary>
    
      <category term="Node" scheme="https://xovel.cn/categories/node/"/>
    
    
      <category term="node" scheme="https://xovel.cn/tags/node/"/>
    
      <category term="wxpay" scheme="https://xovel.cn/tags/wxpay/"/>
    
      <category term="公众号" scheme="https://xovel.cn/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Gulp 4 已发布！</title>
    <link href="https://xovel.cn/article/gulp-4.html"/>
    <id>https://xovel.cn/article/gulp-4.html</id>
    <published>2018-01-10T15:29:19.000Z</published>
    <updated>2018-01-10T16:29:05.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>千呼万唤始出来，犹抱琵琶半遮面。</p>
</blockquote>
<p>在这一天发布的日子里面，其实 <code>gulp</code> 一口气是出了四个版本的：</p>
<ul>
<li><code>v4.0.0-alpha.1</code></li><li><code>v4.0.0-alpha.2</code></li><li><code>v4.0.0-alpha.3</code></li><li><code>v4.0.0</code></li></ul>
<p>前面三个是打了 <code>pre-release</code> 的标签的。</p>
<p><a href="https://github.com/gulpjs/gulp/releases" target="_blank" rel="noopener">更新记录</a>这里就不赘述了，简单来说一下发布带来的新特性吧。</p>
<p>首先是 API 的变化，新增了两个非常重要的改进：<code>gulp.parallel</code> 和 <code>gulp.series</code>。这一点我之前在<a href="https://github.com/xovel/diary/blob/master/2017/10/2017-10-22-gulp-4.md" target="_blank" rel="noopener">个人日志项目</a>里面也进行过记录，当时的说明还是略显简陋的。</p>
<p><code>gulp.parallel</code> 是用于执行并联任务的，相对的 <code>gulp.series</code> 则用于执行串联任务。</p>
<p><code>gulp</code> 任务的处理内核由之前的 <a href="https://github.com/robrich/orchestrator" target="_blank" rel="noopener"><code>orchestrator</code></a> 迁移到为 <code>gulp</code> 而生的 <a href="https://github.com/gulpjs/undertaker" target="_blank" rel="noopener"><code>undertaker</code></a>。迁移之后的处理方式更加高效便捷。支持的任务命名方式也灵活许多。</p>
<p><code>gulp.task</code> 调整，删除之前第二个任务列表的参数，前置任务之类的全部并入到上面的两个 API 中进行处理，可以更好的控制 <code>gulp</code> 任务的执行顺序。</p>
<p><code>gulp.watch</code> 改进，在 <a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener"><code>chokidar</code></a> 的基础上支持各种文件操作方式的监视。</p>
<p>另外新增了几个 API：</p>
<ul>
<li><code>gulp.symlink</code> 用于创建 <code>symlinks</code>。</li><li><code>gulp.lastRun</code> 用于获得指定任务上一次的执行时间。</li><li><code>gulp.tree</code> 用于获取当前任务的树形结构。</li><li><code>gulp.registry</code> 用于获取或者设置注册任务。</li></ul>
<p>所有 API 的详细说明可以在这里找到：<a href="https://github.com/gulpjs/gulp/blob/v4.0.0/docs/API.md" target="_blank" rel="noopener">https://github.com/gulpjs/gulp/blob/v4.0.0/docs/API.md</a>。</p>
<p>另外，对于命令行执行方式，也添加更加丰富的指令，详情可以参阅：<a href="https://github.com/gulpjs/gulp/blob/v4.0.0/docs/CLI.md" target="_blank" rel="noopener">https://github.com/gulpjs/gulp/blob/v4.0.0/docs/CLI.md</a></p>
<p>更新之后，对现有的生态系统影响不会太大，因为还是保留了 <code>v3.9.1</code> 的安装方式。要安装 <code>v4</code>，需要使用 <code>npm install gulp@next</code> 命令来进行安装和获取。这些也都在其 <code>README.md</code> 文件里面有详细说明。</p>
<hr>
<p>鉴于发布的太过于突然，我来不及反应，也暂时没有想法要将现有系统的构建脚本升级到适配 <code>gulp v4</code> 的版本。</p>
<p>前不久在 <code>parcel</code> 爆发之后，自己曾经说过，<code>gulp v4</code> 发布遥遥无期，这还不到一个月，我就被打脸了，想想也真是如梦如幻啊。</p>
]]></content>
    
    <summary type="html">
    
      是的，就在 2017 与 2018 交替的时间里面，gulp v4 发布了，发布时间为北京时间 2018 年 1 月 1 日 上午 9 点。
    
    </summary>
    
      <category term="随笔" scheme="https://xovel.cn/categories/essay/"/>
    
    
      <category term="gulp" scheme="https://xovel.cn/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>2017 年总结</title>
    <link href="https://xovel.cn/article/summary-2017.html"/>
    <id>https://xovel.cn/article/summary-2017.html</id>
    <published>2017-12-31T13:20:48.000Z</published>
    <updated>2018-01-01T12:11:52.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转眼已经是 2017 年的最后一天了，是时候来好好做一个全面的总结了。</p>
</blockquote>
<p>以上这段文字是<del>抄袭</del>自去年的总结。</p>
<p>今年的总结就换一个方式吧。</p>
<h3 id="先做检讨"><a href="#先做检讨" class="headerlink" title="先做检讨"></a>先做检讨</h3><p>2017 年设定了许多的目标，但是很遗憾，基本上没有完成。最为痛心的是继续弃坑《圣血记》，这一部当初踌躇满志气势恢宏的小说，如今也只剩一声叹息。或许是现实生活与我的理念背道而驰，或许是自己的诸多想法不切实际过于天真，导致我没有太多的心思去创作。近期我每每念及此处，都不禁哀叹遗憾。</p>
<!--
《圣血记》是一部作者用来反应社会现实的玄幻浪漫主义小说，有些架空和修仙的成分。有三部曲，前两部分别为《鸣泉录》、《寻玉》，最后一部暂未进行构思（有强烈的依赖关系）。了解这个系列的人应该会知道我为什么没有给第三部定名。

《鸣泉录》是以作者自己为原型，用一种近乎自恋的手法来描述了一段荡气回肠的爱情故事。故事玄幻色彩很重，讲述了幽冥、驾驭魂魄的一些的现实生活中几乎不可能发生的事情，也在试图为幽魂之事正名，使其显得并不那么幽暗恐怖。《鸣泉录》因为故事中映射的女主角原型的人生经历变化，已被作者强行中止，整个故事的走向发生了剧变。在宏大场面还没有来得及展开的情况下强行中止，说起来也是一种遗憾。

《寻玉》讲述的是另一位与《鸣泉录》男主人公有密切联系（为表兄弟关系）的人物寻找失落宝物相关的故事，故事本身其实是一个很大的轮回。遍寻许久没有找到的东西，原来一直就在自己身边，这也是作者将“远在天边近在眼前”的种种擦肩错过进行艺术化处理的尝试。《鸣泉录》中未能叙述的故事也将在《寻玉》中进行补充。而正当进行到了补充的阶段，《寻玉》也难以继续下去。

我想这应该是一个我绕不过去的坎。总之，从 2016 年下半年开始，就一直搁置了《圣血记》的故事创作。原本打算 2017 年进行重构，但诸多之前的设定都发生了变化，我没有继续创作下去。整个 2017 年，只写了一部分关于《鸣泉录》男主角恢复神志的情节。如今，回过头看《寻玉》的创作，都快变成多主人公的设定了，有点模仿《天龙八部》和《海上牧云记》的节奏。

在阅读一些作品的评鉴的时候，得知一个这样的信息：所有的小说创作，其背景其实都是为了剧情和人物而服务。如果依赖背景去进行创作，除非是有一个非常统一并且经得起推敲的背景故事，否则往往会令人曲解了故事的本原。

*****************

好了，上面其实都是扯谈，意图分散诸君的注意力，也是在弱化自己的侧重点。
-->
<p>工作方面，没有能够稳定住现有的工作。是的，我在 11 月份的时候从上一家公司离职了。上一家公司对我很好，同事之间相处也非常融洽，领导也很是器重我。我选择离开，无论如何，都是工作不稳定的一种体现。原本自己是想打算在上一家公司静静打拼两年，积攒一些人脉，但是事实上我并没有这样去做。这也可能是促使我做出离职决定的一个重大原因吧。</p>
<p>生活方面，说来也甚是杯具。我依然在人生的道路上孤军奋战，我内心多么渴望能有一个人和我一起共同面对未知的旅途呀。说多了都是泪的节奏，归根结底都是因为自己自身的原因。所幸，2017 年，我到底还是学会了如何去勇敢面对。有时候内心面临崩溃，身边又孤立无援的时候，我不再像之前在杭州那般堕落消极，而是努力寻找解决方案。</p>
<h3 id="挖过的坑"><a href="#挖过的坑" class="headerlink" title="挖过的坑"></a>挖过的坑</h3><p>2017 年，我给自己是挖了很多的坑的。这里也稍作罗列，希望还能有时间和精力去填补。</p>
<ol>
<li><code>zob</code> 项目。该项目最初设定的是解决 <code>MVVM</code> 框架的问题，后来项目失败，项目的定位迁移成了代码和写作风格指导。</li><li><code>moonlight</code> 项目。该项目原本计划是在 2017 年产出至少两个的子项目，但是很遗憾，目前只有一个半成品的小项目。</li><li><code>lui</code> 项目。这个坑挖的太大了，导致项目直接崩盘。该项目的定位是用于解决终端之间的样式风格问题，而目前市面上的大多数 UI 库都致力于解决这个问题，并不是一朝一夕的事情。<del><code>L</code> 是法语单词 <code>libellule</code> 的首字母，意思为<em>蜻蜓</em></del>。</li><li>创作系列之<strong>内心小剧场</strong>。这其实也算是一个不大不小的坑，最初的灵感来源是国庆假期的时候去见了她。一直想用一些文字来描述自己的内心世界，开设这个小项目，也是为了释放一下自己心中的情感。</li><li>代码风格统一化。这也算团队协作的一个组成部分吧，然而目前只是做到了自己编码风格的统一，并没有对团队成员做统一规范要求。</li></ol>
<h3 id="有过的想法"><a href="#有过的想法" class="headerlink" title="有过的想法"></a>有过的想法</h3><p>在 2017 年有过的想法，但是一直没有去执行的事情：</p>
<ol>
<li>日历项目。记录所有重要的日期。</li><li>运营一个微信公众号。</li><li>收集某一垂直领域的相关资料。拟定的方向有两个，分别为养生和建筑。</li><li>成为 <code>vue.js</code> 的贡献者。</li></ol>
<p>可以将理由统一定性为懒惰，不思进取。这些事情也逐渐让我明白了一个道理：一个人的精力毕竟还是有限的。</p>
<hr>
<p>下面来总结一下 2017 可圈可点的事情：</p>
<h3 id="接手的项目"><a href="#接手的项目" class="headerlink" title="接手的项目"></a>接手的项目</h3><h4 id="中小学装备管理系统"><a href="#中小学装备管理系统" class="headerlink" title="中小学装备管理系统"></a>中小学装备管理系统</h4><p>上一家公司拳头产品，我在其中负责前端的开发。</p>
<h4 id="集中采购系统"><a href="#集中采购系统" class="headerlink" title="集中采购系统"></a>集中采购系统</h4><p>上一家公司的另一款采购物品的管理后台产品，与装备管理系统密切相关。同样的，我也是前端主程。</p>
<h4 id="数据直报系统"><a href="#数据直报系统" class="headerlink" title="数据直报系统"></a>数据直报系统</h4><p>与上一个项目基本类似，用于学校端的数据填写上报，行管端的审批与汇总，方便管理系统进行数据的统一管理。</p>
<blockquote>
<p>以上各个项目的版本因为公司的战略计划，统一都是 <code>V9</code>。</p>
</blockquote>
<h4 id="实验教学平台"><a href="#实验教学平台" class="headerlink" title="实验教学平台"></a>实验教学平台</h4><p>该项目分为三个迭代阶段，我都参与了。第一个阶段为项目雏形时期，采用传统的 <code>jQuery/Bootstrap</code> 搭建，该阶段直接被第二个阶段替代。第二个阶段为采用 <code>angular.js</code> 进行搭建，我参与了主框架的搭建，并进行了路由配置以及懒加载方案的探索与实现。第三个阶段为 <code>vue.js</code> 阶段，此阶段为项目前端正式转型之后采用的框架，我只参与了部分主框架的搭建，之后因公司战略调整，我回到了装备开发团队。</p>
<h4 id="空港出行管理后台"><a href="#空港出行管理后台" class="headerlink" title="空港出行管理后台"></a>空港出行管理后台</h4><p>这便就是当前自己经手的核心项目。</p>
<h3 id="与工作相关的子项目"><a href="#与工作相关的子项目" class="headerlink" title="与工作相关的子项目"></a>与工作相关的子项目</h3><h4 id="sinput-js"><a href="#sinput-js" class="headerlink" title="sinput.js"></a><a href="https://github.com/xovel/sinput/tree/1.x" target="_blank" rel="noopener"><code>sinput.js</code></a></h4><p>一个用于列表模糊检索的 <code>jQuery</code> 插件。因前面提到的装备管理系统中，存在大量的模糊检索的需求，为了应对复杂的产品需求，在采用了诸多现有的插件之后，便有了这样一个子项目的诞生。主要目的是解决千奇百怪的需求。插件性能和效果表现均十分良好。</p>
<h4 id="dreport-xlsx"><a href="#dreport-xlsx" class="headerlink" title="dreport-xlsx"></a><code>dreport-xlsx</code></h4><p>因数据直报系统中使用到了大量的表格导入导出功能，后台人员在制作模板的过程中，需要面临大量重复冗余的操作，遂在 <code>node-xlsx</code> 的基础之上，为缩短人工操作的时间和避免操作失误，开发了这一款用于生成数据模板的子项目。</p>
<blockquote>
<p>不过，因为离职走的匆忙，相关的代码我没有带走。</p>
</blockquote>
<h4 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a><code>util.js</code></h4><p>单独将此拎出来是因为该文件的定位至关重要。该项目收集并整理了部分在前端开发中使用频率非常高的工具方法。在上一家公司之后，又加入诸多方法比如重新封装 <code>ajax</code> 方法，表格组件的支持更加丰富，加入了部分类似与 <code>vue</code> 和 <code>angular</code> 过滤器的概念方法等等。</p>
<h3 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h3><h4 id="htree"><a href="#htree" class="headerlink" title="htree"></a><a href="https://github.com/xovel/htree" target="_blank" rel="noopener"><code>htree</code></a></h4><p>一款用于 <code>node.js</code> 环境的类似于 <code>Linux</code> 系统的 <code>tree</code> 命令的命令行工具。更多介绍可以参考之前在博客中发表的这篇文章：<a href="/article/htree.html">htree，一款模仿 tree 命令的本地文件结构查看工具</a>。</p>
<h4 id="最合拍"><a href="#最合拍" class="headerlink" title="最合拍"></a>最合拍</h4><p>一款面向羽毛球运动的微信商城项目。<del>后该项目因为迭代升级原因，我个人退出下一个版本的开发</del>。</p>
<h4 id="第五空间文学网"><a href="#第五空间文学网" class="headerlink" title="第五空间文学网"></a>第五空间文学网</h4><p>一款面向小说后台管理的静态页面实现。</p>
<h3 id="新增的技术栈"><a href="#新增的技术栈" class="headerlink" title="新增的技术栈"></a>新增的技术栈</h3><ul>
<li><code>angular.js</code>。开始对大型应用的 <code>MVVM</code> 模式做深入的了解与应用。</li><li><code>jenkins</code> 的使用，本人的日志项目中有许多记录是关于 <code>jenkins</code> 这一款 <code>CI</code> 系统的。</li><li><code>gulp</code> 构建复杂的大型应用。配合简单的 <code>node</code> 命令完成各种场景需求。</li><li><code>node.js</code> 编写简单基础的应用。如上面提到的 <code>dreport-xlsx</code>，上一条提到的 <code>gulp</code> 生成 <code>config</code> 配置文件，均采用 <code>node</code> 执行文件来产出。</li><li><code>nginx</code> 搭建与配置，代理纯前端站点。多文件的配置模式。</li><li><code>xshell</code> 连接远程主机进行调试。主要是操作 <code>nginx</code> 和查看 <code>tomcat</code> 的后台日志记录文件。</li><li><code>webpack</code> 技术，使用 <code>vue</code> 进行项目的骨架搭建。</li><li><code>vue</code>，非常优秀的前端框架，算是入了门。组件库的使用这里就不赘述了。</li></ul>
<h3 id="阅读与写作"><a href="#阅读与写作" class="headerlink" title="阅读与写作"></a>阅读与写作</h3><p>说来惭愧，2017 年，自己的写作任务全面处于弃坑状态，所以这里就针对自己的阅读情况做一个简单的记录。</p>
<ul>
<li>《圣血记》的创作，持续搁置。“她”的原型再度丢失，我失去了创作的方向。</li><li>购买了一些技术方面的书籍，如《代码整洁之道》、《深入理解 ES6》、《HTTP 指南》等。基本上都是下半年购买的，远远没有达到年初既定的目标（<code>≥ 10</code>）。</li><li>图书馆去的次数大概在 20 次，每次借阅的书籍数量平均为两本。也是没有能够达到最初的目标的。书籍的范围大都是技术和哲学相关的。希望 2018 年能够借阅更多类型的书籍来拓展自己的知识视野。</li><li>各大博客和站点，以掘金、简书、开发者头条、干货集中营、前端之巅、前端日刊等为代表，几乎推送过来的文章，跟前端和 UI 相关的都进行了阅读，并针对部分文章做了收藏与整理记录。</li><li>个人博客的创作，2017 年的产出量不超过 10 篇，能拿得出手的其实只有两篇，一篇是介绍 <code>brackets</code> 插件的，另一篇是介绍 <code>htree</code> 的。</li><li>个人日志项目，坚持了下来。虽然每天都记录了，但是个人认为有效记录的比率在 60% 左右（即有大约 30% ~ 40% 是并没有什么实际意义的记录或者是流水账式的记录）。我会抽一个时间对 2017 年写下的日志做一个整理，看看自己的技术成长路线是个什么样子的。<del>嗯，这又算是给自己挖了一个坑</del>。</li></ul>
<h3 id="关于音乐"><a href="#关于音乐" class="headerlink" title="关于音乐"></a>关于音乐</h3><p>截止目前为止，我在网易云音乐上面的听歌总数达到了八千多首，主要类型可以分为两类，一类是纯音乐，包括史诗、空间、纯电音、新世纪等等；另一类是柔和舒缓类型的。</p>
<p>自己的音乐梦想，到目前为止，已经中断将近 20 年了。说起来也甚是滑稽可笑，我其实是有条件进一步接触音乐的，但我一直没有勇气将其拎起来。我并不知道何时才能重拾年幼时的梦想，也可能一辈子都不会再捡起来了吧。</p>
<p>自己的歌唱水平比以前好了很多很多。以前 100% 走调的我，现在也能逐渐掐准节奏了。深情，有故事，这是我得到的最多的评价。</p>
<h3 id="展望-2018"><a href="#展望-2018" class="headerlink" title="展望 2018"></a>展望 2018</h3><p>说了这么多，我其实也是在一直犹豫，对于 2018 年的规划是什么样子的，其实早在 2017 年 7 月份，我就已经做出了明确的规划。</p>
<p>有些事情，是不方便明说的。2017 年没有来得及完成的事情，2018 年也不会特意去处理，毕竟各有各的规划。若是刻意去完成某件事情，是否又偏离了原定计划呢？</p>
<p>简单粗暴的总结一下 2018 年的展望：</p>
<ul>
<li>遇见更好的自己。</li><li>让自己内心更加平静。</li><li>努力提升自己的情商和魅力值。</li></ul>
<blockquote>
<p>嗯，后面两点是<del>充数</del>的。</p>
</blockquote>
<hr>
<blockquote>
<p><em>知道的越多，就越发现自己不知道的其实更多</em>。<del>这句不是鲁迅说的，是古希腊大哲学家芝诺说的</del>。</p>
<p>因此而产生恐惧，那是万万不可取的。</p>
</blockquote>
<hr>
<p>2018 年，加油！</p>
]]></content>
    
    <summary type="html">
    
      2017 年年末大总结。
    
    </summary>
    
      <category term="生活" scheme="https://xovel.cn/categories/life/"/>
    
    
      <category term="2017" scheme="https://xovel.cn/tags/2017/"/>
    
      <category term="总结" scheme="https://xovel.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="经历" scheme="https://xovel.cn/tags/%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="https://xovel.cn/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>中国的商标分类</title>
    <link href="https://xovel.cn/article/trademark-classification.html"/>
    <id>https://xovel.cn/article/trademark-classification.html</id>
    <published>2017-12-31T11:54:33.000Z</published>
    <updated>2017-12-31T15:58:52.650Z</updated>
    
    <content type="html"><![CDATA[<p>商标是区别商品或服务来源的一种标志，每一个注册商标都是指定用于某一商品或服务上的。</p>
<a id="more"></a>
<p>不想引述大段现有的资料。</p>
<p>打算设立一个项目，就是针对开启高强度的模糊搜索效果的商标范围在线搜索。</p>
<p>为什么不提供精确的商标查询效果？说来惭愧，没有能够顺利破解 <code>商标网</code> 提供的 <code>API</code>。前天听后台开发的同事讲解了一些开放平台和网关拦截的知识，我想我是碰到了。我没有找到合适的破解方案，时间一到就告知权限失效或者查无数据了。所以，暂时先提供一个商标范围的搜索项目，名字就叫做 <code>trademark-classification</code>。所有数据来源来自商标网的官方数据，采集时间为 <code>2017-10-31</code>。</p>
<p>部分参考资料：</p>
<ul>
<li><a href="http://sbj.saic.gov.cn/sbsq/sphfwfl/" target="_blank" rel="noopener">商标注册用商品和服务分类说明</a></li><li><a href="http://wsjs.saic.gov.cn" target="_blank" rel="noopener">中国商标网</a></li></ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;商标是区别商品或服务来源的一种标志，每一个注册商标都是指定用于某一商品或服务上的。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://xovel.cn/categories/essay/"/>
    
    
      <category term="商标" scheme="https://xovel.cn/tags/%E5%95%86%E6%A0%87/"/>
    
      <category term="分类" scheme="https://xovel.cn/tags/%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>PARCEL - 一个极快零配置的打包工具</title>
    <link href="https://xovel.cn/article/parcel-bundler.html"/>
    <id>https://xovel.cn/article/parcel-bundler.html</id>
    <published>2017-12-12T01:33:28.000Z</published>
    <updated>2017-12-12T01:51:43.059Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx4.sinaimg.cn/large/79be2309gy1fmdqbevvmgj20m806dmz8.jpg" alt=""></p>
<blockquote>
<p>前端的发展真是日新月异，这不，打包工具方面最近又出了一个爆款，名字叫做 <code>parcel</code>。本篇博客转载其 <code>README.md</code>，暂不做翻译。原文请移步：<a href="https://github.com/parcel-bundler/parcel" target="_blank" rel="noopener">parcel-bundler/parcel</a>。</p>
</blockquote>
<hr>
<p>Blazing fast, zero configuration web application bundler <a href="https://parceljs.org" target="_blank" rel="noopener">https://parceljs.org</a></p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>🚀 <strong>Blazing fast</strong> bundle times - multicore compilation, and a filesystem cache for fast rebuilds even after a restart.</li><li>📦 Out of the box support for JS, CSS, HTML, file assets, and more - <strong>no plugins to install</strong>.</li><li>🐠 <strong>Automatically transforms modules</strong> using Babel, PostCSS, and PostHTML when needed - even <code>node_modules</code>.</li><li>✂️ Zero configuration <strong>code splitting</strong> using dynamic <code>import()</code> statements.</li><li>🔥 Built in support for <strong>hot module replacement</strong></li><li>🚨 Friendly error logging experience - syntax highlighted code frames help pinpoint the problem.</li></ul>
<h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><ol>
<li>Install with yarn:</li></ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add parcel-bundler</span><br></pre></td></tr></table></figure>
<p>or with npm:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g parcel-bundler</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Parcel can take any type of file as an entry point, but an HTML or JavaScript file is a good place to start. If you link your main JavaScript file in the HTML using a relative path, Parcel will also process it for you, and replace the reference with a URL to the output file.</li></ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>Parcel has a development server built in, which will automatically rebuild your app as you change files and supports hot module replacement for fast development. Just point it at your entry file:</li></ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel index.html</span><br></pre></td></tr></table></figure>
<ol>
<li>Now open <a href="http://localhost:1234/" target="_blank" rel="noopener">http://localhost:1234/</a> in your browser. If needed, you can also override the default port with the -p option.</li></ol>
<p>See <a href="https://parceljs.org" target="_blank" rel="noopener">parceljs.org</a> for more documentation!</p>
<h2 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h2><p>Based on a reasonably sized app, containing 1726 modules, 6.5M uncompressed. Built on a 2016 MacBook Pro with 4 physical CPUs.</p>
<table>
<thead>
<tr>
<th>Bundler</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>browserify</td>
<td>22.98s</td>
</tr>
<tr>
<td>webpack</td>
<td>20.71s</td>
</tr>
<tr>
<td><strong>parcel</strong></td>
<td><strong>9.98s</strong></td>
</tr>
<tr>
<td><strong>parcel - with cache</strong></td>
<td><strong>2.64s</strong></td>
</tr>
</tbody>
</table>
<h2 id="Why-parcel"><a href="#Why-parcel" class="headerlink" title="Why parcel?"></a>Why parcel?</h2><p>There are many web application bundlers out there with huge adoption, including webpack and browserify. So, why do we need another one? The main reasons are around developer experience.</p>
<p>Many bundlers are built around configuration and plugins, and it is not uncommon to see applications with upwards of 500 lines of configuration just to get things working. This configuration is not just tedious and time consuming, but is also hard to get right and must be duplicated for each application. Oftentimes, this can lead to sub-optimized apps shipping to production. <code>parcel</code> is designed to need zero configuration: just point it at the entry point of your application, and it does the right thing.</p>
<p>Existing bundlers are also very slow. Large applications with lots of files and many dependencies can take minutes to build, which is especially painful during development when things change all the time. File watchers can help with rebuilds, but the initial launch is often still very slow. <code>parcel</code> utilizes worker processes to compile your code in parallel, utilizing modern multicore processors. This results in a huge speedup for initial builds. It also has a file system cache, which saves the compiled results per file for even faster subsequent startups.</p>
<p>Finally, existing bundlers are built around string loaders/transforms, where the transform takes in a string, parses it, does some transformation, and generates code again. Oftentimes this ends up causing many parses and code generation runs on a single file, which is inefficient. Instead, <code>parcel</code>‘s transforms work on ASTs so that there is one parse, many transforms, and one code generation per file.</p>
<h2 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h2><p><code>parcel</code> transforms a tree of assets to a tree of bundles. Many other bundlers are fundamentally based around JavaScript assets, with other formats tacked on - for example, by default inlined as strings into JS files. <code>parcel</code> is file-type agnostic - it will work with any type of assets the way you’d expect, with no configuration.</p>
<p><code>parcel</code> takes as input a single entry asset, which could be any type: a JS file, HTML, CSS, image, etc. There are various asset types defined in <code>parcel</code> which know how to handle specific file types. The assets are parsed, their dependencies are extracted, and they are transformed to their final compiled form. This creates a tree of assets.</p>
<p>Once the asset tree has been constructed, the assets are placed into a bundle tree. A bundle is created for the entry asset, and child bundles are created for dynamic imports, which cause code splitting to occur. Child bundles are also created when assets of a different type are imported, for example if you imported a CSS file from JavaScript, it would be placed into a sibling bundle to the corresponding JavaScript. If an asset is required in more than one bundle, it is hoisted up to the nearest common ancestor in the bundle tree so it is not included more than once.</p>
<p>After the bundle tree is constructed, each bundle is written to a file by a packager specific to the file type. The packagers know how to combine the code from each asset together into the final file that is loaded by a browser.</p>
<h2 id="Community"><a href="#Community" class="headerlink" title="Community"></a>Community</h2><p>All feedback and suggestions are welcome!</p>
<ul>
<li>💬 Chat: Join us on <a href="https://slack.parceljs.org/" target="_blank" rel="noopener">slack</a>.</li><li>📣 Stay up to date on new features and announcements on <a href="https://twitter.com/parceljs" target="_blank" rel="noopener">@parceljs</a>.</li></ul>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p>
<hr>
<p><a href="http://www.css88.com/doc/parcel/" target="_blank" rel="noopener">Parcel 中文文档</a>。不得不佩服这个网站，以飞快之速完成了对文档的翻译。<del>当然，现在的官方文档内容其实也不多</del>。</p>
<p>目前这个项目吸引了很多的开发者，诸多在 <code>webpack</code> 中的特性也会逐步加入进来，不出意外的话，这个是继 <code>rollup</code> 之后，又一个与 <code>webpack</code> 争天下的项目。</p>
]]></content>
    
    <summary type="html">
    
      前端的发展真是日新月异，这不，打包工具方面最近又出了一个爆款，名字叫做 `parcel`。本文转载其说明文档 `README.md`。
    
    </summary>
    
      <category term="开发" scheme="https://xovel.cn/categories/dev/"/>
    
      <category term="文档" scheme="https://xovel.cn/categories/dev/docs/"/>
    
    
      <category term="parcel" scheme="https://xovel.cn/tags/parcel/"/>
    
      <category term="bunlder" scheme="https://xovel.cn/tags/bunlder/"/>
    
  </entry>
  
  <entry>
    <title>编程命名规则</title>
    <link href="https://xovel.cn/article/naming-rule.html"/>
    <id>https://xovel.cn/article/naming-rule.html</id>
    <published>2017-09-24T04:07:13.000Z</published>
    <updated>2017-09-24T08:21:16.547Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things. – Phil Karlton</p>
</blockquote>
<p>正如上面这一句经典的话语，道出了计算机领域两个最大的难题：命名与缓存。</p>
<p>本文就“命名”这个东西，做一个浅显的解读。</p>
<h3 id="匈牙利命名法"><a href="#匈牙利命名法" class="headerlink" title="匈牙利命名法"></a>匈牙利命名法</h3><p>该方法也叫做 <code>HN 命名法</code>，通常认为是微软的一个雇员 <code>Charles Simonyi</code> 发明的，通过微软的各种产品和文档资料传播开来。这位雇员是一个匈牙利（Hungarian）人，这也就是这个命名方法的名字由来。</p>
<p>匈牙利命名法的基本原则是：变量名依次由属性、类型、描述组成。</p>
<p>这里就通过举例来进行直接的说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iUserName; <span class="comment">// i 为 int 类型缩写</span></span><br><span class="line"><span class="keyword">char</span> cItemList; <span class="comment">// c 为 char 类型缩写</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bInitLogin; <span class="comment">// b 为 布尔值 boolean 缩写</span></span><br></pre></td></tr></table></figure>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dim</span> frmInfoDetail; <span class="comment">' frm 为窗体 form 的缩写</span></span><br></pre></td></tr></table></figure>
<h3 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h3><p>驼峰命名法 <code>camelCase</code>，来自于 Perl 语言普遍使用的大小写混合格式，后来被 Java 广泛采用，逐渐成为更加通用的命名方法。</p>
<p>驼峰命名法的基本规则是变量名或者函数名是由一个或者多个单词连接在一起，构成唯一识别符，第一个单词以小写字母开始，后面的单词首字母大写，这样看起来跟驼峰一样此起彼伏，故此得名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myStudentCount;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFileSync</span><br></pre></td></tr></table></figure>
<h3 id="帕斯卡命名法"><a href="#帕斯卡命名法" class="headerlink" title="帕斯卡命名法"></a>帕斯卡命名法</h3><p>跟驼峰命名法类似，帕斯卡命名法 <code>PascalCase</code> 的不同之处在于第一个单词首字母为<strong>大写</strong>。在一些构造器命名和全局特殊变量命名的时候通常会采用这种命名方法。</p>
<p>鉴于跟驼峰命名法的相似，也有人将帕斯卡命名法称之为 <code>大驼峰命名法</code>，而上面的就称之为 <code>小驼峰命名法</code>。</p>
<h3 id="蛇形命名法"><a href="#蛇形命名法" class="headerlink" title="蛇形命名法"></a>蛇形命名法</h3><p>蛇形命名法 <code>snake_case</code>，变量名由多个部分组成，每个部分之间使用下划线 <code>_</code> 进行连接，所以也称之为 <code>下划线命名法</code>。</p>
<h3 id="脊柱命名法"><a href="#脊柱命名法" class="headerlink" title="脊柱命名法"></a>脊柱命名法</h3><p>脊柱命名法 <code>spinal-case</code>，跟蛇形命名法类似，不过连接符为连接符 <code>-</code>。也称之为 <code>kebab-case</code>、<code>train-case</code>。在 URL 命名，HTML 属性、CSS 属性、Lisp 语言比较常见，所以也称之为 <code>lisp-case</code>。</p>
<blockquote>
<p>kebab 意思是阿拉伯烤肉，与 train、spinal 一样，因为其生动的形象，跟连字符风格类似，均以此得名。</p>
</blockquote>
<h3 id="混杂大小写"><a href="#混杂大小写" class="headerlink" title="混杂大小写"></a>混杂大小写</h3><p><code>Studly caps</code>，这一种命名方法，其实我不知道该如何去翻译和描述，算是一种很非主流的命名方式。就是杂乱无章的大小写混拼方式。比如这种命名方式来命名自己的名称，可以是 StUdLyCaPs 或者 STuDLyCaPS。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实上面的种种命名方式，在语义学上面，统称为 <code>case</code>。这也是为什么其英文名称中大都出现了 <code>case</code> 这个词眼的原因。</p>
<p>现罗列一下常见的各种 <code>case</code>，每一种都是用自身的方式进行书写的。</p>
<ul>
<li><code>CamelCase</code></li><li><code>snake_case</code></li><li><code>kebab-case</code></li><li><code>StUdLyCaPs</code></li></ul>
<p>另外加上两个<del>凑数</del>：</p>
<ul>
<li><code>lowercase</code></li><li><code>UPPERCASE</code></li></ul>
<blockquote>
<p>嗯。是的，一个是小写，一个是大写。</p>
</blockquote>
<hr>
<p>在如今的编码过程中，并不会总是遵循某一种规则，而是各种风格混合使用，这样也能更好的适应当前的业务场景。</p>
]]></content>
    
    <summary type="html">
    
      编程命名规则有很多种，本文就简单做一个介绍。
    
    </summary>
    
      <category term="开发" scheme="https://xovel.cn/categories/dev/"/>
    
    
      <category term="naming" scheme="https://xovel.cn/tags/naming/"/>
    
      <category term="case" scheme="https://xovel.cn/tags/case/"/>
    
  </entry>
  
  <entry>
    <title>htree，一款模仿 tree 命令的本地文件结构查看工具</title>
    <link href="https://xovel.cn/article/htree.html"/>
    <id>https://xovel.cn/article/htree.html</id>
    <published>2017-09-21T14:53:22.000Z</published>
    <updated>2017-09-22T01:09:05.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="htree-介绍"><a href="#htree-介绍" class="headerlink" title="htree 介绍"></a>htree 介绍</h3><p>首先，介绍一下 <a href="https://github.com/xovel/htree" target="_blank" rel="noopener"><code>htree</code></a> 这一款工具。<code>htree</code> 是一款用于在 <code>node</code> 环境下运行的工具，安装之后可以直接在 <code>node</code> 命令行窗口输入 <code>htree</code> 进行使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">E:\Git\xovel\htree</span><br><span class="line">├─index.js</span><br><span class="line">├─LICENSE</span><br><span class="line">├─package.json</span><br><span class="line">├─README.md</span><br><span class="line">├─bin</span><br><span class="line">│  └─htree</span><br><span class="line">├─docs</span><br><span class="line">│  └─help</span><br><span class="line">├─node_modules</span><br><span class="line">└─util</span><br><span class="line">   ├─genText.js</span><br><span class="line">   ├─getByteLength.js</span><br><span class="line">   ├─getSize.js</span><br><span class="line">   ├─getTextList.js</span><br><span class="line">   └─walk.js</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码为在 <code>htree</code> 开发文件夹的命令行工具下执行命令 <code>htree</code> 生成的结果。</p>
</blockquote>
<h3 id="参数简介"><a href="#参数简介" class="headerlink" title="参数简介"></a>参数简介</h3><p><code>htree</code> 目前版本为 <code>0.2.0</code>，支持的参数如下：</p>
<h4 id="ignore"><a href="#ignore" class="headerlink" title="ignore"></a>ignore</h4><p>忽略列表，为一个数组，包括文件和文件夹。在列表之中的值均会跳过不进行处理。</p>
<h4 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h4><p>排除的文件夹。该值如果设置，应该是一个正则表达式。符合正则表达式匹配的文件夹会跳过。</p>
<h4 id="maxDepth"><a href="#maxDepth" class="headerlink" title="maxDepth"></a>maxDepth</h4><p>读取文件夹的最大深度。该深度是基于当前传入的文件夹。</p>
<h4 id="gap"><a href="#gap" class="headerlink" title="gap"></a>gap</h4><p>布尔值，为真则在文件/文件夹名称前面添加一个空格。</p>
<h4 id="concatLength"><a href="#concatLength" class="headerlink" title="concatLength"></a>concatLength</h4><p>节点前缀和文件/文件名之间的连接符的长度。</p>
<h4 id="indent"><a href="#indent" class="headerlink" title="indent"></a>indent</h4><p>布尔值，为真则在子文件/文件夹前面添加空格作为缩进。</p>
<h4 id="indentLength"><a href="#indentLength" class="headerlink" title="indentLength"></a>indentLength</h4><p>上面的缩进的空格的长度。</p>
<h4 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h4><p>布尔值，是否在文件夹后面添加一个后缀，默认不添加。</p>
<h4 id="strSuffix"><a href="#strSuffix" class="headerlink" title="strSuffix"></a>strSuffix</h4><p>上面的后缀的文本，默认为 <code>/</code>。</p>
<h4 id="strComment"><a href="#strComment" class="headerlink" title="strComment"></a>strComment</h4><p>注释标识符，类型为字符串。如果设置为非空字符串，<code>htree</code> 会自动计算文件/文件夹最大长度，然后再拼接 <code>padLength</code> 长度的空格，之后拼接 <code>strComment</code> 作为列表文本。非最大长度的行会使用空格进行补正对齐。</p>
<h4 id="padLength"><a href="#padLength" class="headerlink" title="padLength"></a>padLength</h4><p>补齐 <code>strComment</code> 所用的空格的长度。</p>
<h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p><code>htree</code> 的执行主目录，默认为当前命令行窗口所在的文件夹。</p>
<h4 id="folder"><a href="#folder" class="headerlink" title="folder"></a>folder</h4><p>布尔值，为真时只读取文件夹，跳过非文件夹的部分（即普通文件）。</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>布尔值，为真时对同级的文件/文件夹列表进行排序。通常这个设置没有什么效果，但在处理一些特殊字符开头的文件/文件夹之时会用到。默认为真。</p>
<blockquote>
<p>如下划线 <code>_</code> 开头的文件/文件夹默认排在后面。</p>
</blockquote>
<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>布尔值，为真时显示文件的大小，如果 <code>strComment</code>未指定，则将其设置为 <code>#</code>。</p>
<h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>对同级文件/文件夹进行归类显示的参数。为<strong>字符串</strong> <code>after</code> 时，文件会被统一放在文件夹后面；为真的其他情况时，文件会统一放在文件夹前面；为假则不做任何处理。</p>
<h4 id="showDir"><a href="#showDir" class="headerlink" title="showDir"></a>showDir</h4><p>布尔值，为真时在最开始处显示当前执行的文件夹路径。</p>
<h4 id="dot"><a href="#dot" class="headerlink" title="dot"></a>dot</h4><p>布尔值，为真时处理以点号 <code>.</code> 号开头的文件夹，否则跳过。</p>
<h4 id="underline"><a href="#underline" class="headerlink" title="underline"></a>underline</h4><p>布尔值，为真时处理以下划线 <code>_</code> 开头的文件夹，否则跳过。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>上面的所有设置均可以通过命令行方式进行参数指定，指定方式为小写连字符风格的字符串加上 <code>--</code> 的前缀。如要指定最大文件夹访问深度 <code>maxDepth</code> 为 <code>10</code>，则使用命令：<code>htree --max-depth 10</code>，或者 <code>htree --max-depth=10</code>。</p>
<p>支持的短命令列表如下：</p>
<ul>
<li><code>-v</code>，即 <code>--version</code>，显示当前 <code>htree</code> 的版本号。</li><li><code>-h</code>，即 <code>--help</code>，显示当前 <code>htree</code> 的帮助文件。</li><li><code>-f</code>，即 <code>--folder</code>。</li><li><code>-d</code>，即 <code>--dir</code>。</li><li><code>-i</code>，即 <code>--ignore</code>。</li><li><code>-o</code>，即 <code>--output</code>。</li><li><code>-s</code>，即 <code>--show-dir</code>。</li><li><code>-m</code>，即 <code>--max-depth</code>。</li></ul>
<p>为布尔值的参数，可以通过前缀 <code>--no-</code> 设置为 <code>false</code> 值。</p>
<blockquote>
<p>在设置 <code>--dir</code>、<code>--output</code>、<code>--exclude</code>、<code>--str-comment</code> 的值之时，必要时请对特殊字符进行转义操作。</p>
</blockquote>
<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>为什么要开发这一款工具呢？其实很早以前就有过这样的想法，但是后来由于工作忙碌就搁置了。直到最近在处理一个树形结构的展示的时候，需要通过设置自定义数据来实现多级树结构的嵌套生成。这个方式与之前设想的文件夹结构展开方式类似，于是决定将这个项目正式开发出来。</p>
<p>经过陆陆续续的改动，对参数配置进行了较大幅度的修改，版本号目前 <code>0.2.0</code>。项目已经趋于稳定，想来应该是没有什么太大的改动了。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>这个项目里面，算是体验了一把模块化编程。大部分功能都抽离成了模块，<del>虽然也没多少个</del>。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>在获取多级文件夹时候用到了以前上学时期学过的一个技术：递归。</p>
<p>原则上，没有无限极的目录深度，所以递归调用肯定会有某个结束的场景。但是我还是设定了默认的最大目录深度为 <code>5</code>。</p>
<h3 id="npm-相关"><a href="#npm-相关" class="headerlink" title="npm 相关"></a>npm 相关</h3><p>在进行本地开发的时候，我并没有创建 <code>node_modules</code> 文件夹，实际开发中，也没有依赖其他的项目，而在本地连接发布 <code>npm link</code> 的时候会自动进行创建。这也是为什么上面的目录中会有这个文件夹而上传到 <code>github</code> 上面的时候由于默认机制的原因忽略了。之前进行 <code>npm</code> 发布的遇到过一个<a href="https://github.com/xovel/xovel.github.io/issues/26" target="_blank" rel="noopener">不大不小的问题</a>，这一次的发布又遇到了，是的，我又设置了淘宝的国内镜像源。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>开发过程难免碰到一些乍看起来不可思议的问题，比如在获取 <code>windows</code> 磁盘根目录下的文件列表时，由于部分系统文件夹默认禁止访问，如 <code>System Volume Information</code>。即便是开启了管理员权限，也不能直接访问这些文件/文件夹。经过一番思考，目前采用了 <code>try/catch</code> 命令来避免程序报错，并退出当前操作。一些经过特意设置的文件夹如加密过的，也是不能直接读取其属性的，这就无法判断是否是文件夹了。</p>
<p>当然，根据提供的 <code>ignore</code> 和 <code>exclude</code> 参数，可以跳过这些文件/文件夹的访问。</p>
<p>另一个问题是命令行执行的时候，获取当前文件夹错误，原因是最开始的命令行文件 <code>bin/htree</code> 没有对执行的环境进行指定，亦即在最开始的部分并没有这样一句代码：<code>#!/usr/bin/env node</code>。这段代码的作用的是让程序在运行时候的运行环境变为 <code>node</code>，设置为这样之后在获取目录的时候调用 <code>process.cwd()</code> 等方法就表现正常了。</p>
<p>在处理字符串长度的时候，获取字符串的实际占用长度的时候存在一个不大不小的问题，部分字符会占据两个字母的长度，比如中文。由于本人当前主要是在中文环境下面工作，故此在获取字符串长度的时候直接将中文汉字和标点转成了两个字母长度的，再返回其长度，这样来保证设置了 <code>size</code> 或者 <code>strComment</code> 参数的时候，右侧的标识符能够对齐显示。</p>
<p>文件字节长度的计算，这里是采用下面这段代码来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSize</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> suffix = [<span class="string">'B'</span>, <span class="string">'KB'</span>, <span class="string">'MB'</span>, <span class="string">'GB'</span>, <span class="string">'TB'</span>, <span class="string">'PB'</span>, <span class="string">'EB'</span>, <span class="string">'ZB'</span>, <span class="string">'YB'</span>, <span class="string">'DB'</span>, <span class="string">'NB'</span>];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (size &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">    size /= <span class="number">1024</span>;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= suffix.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (i === <span class="number">0</span> ? size : size.toFixed(<span class="number">2</span>)) + <span class="string">' '</span> + suffix[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此还特意去查阅了一下计算机中的相关单位，还是挺有意思的。</p>
<h3 id="关于代码规范"><a href="#关于代码规范" class="headerlink" title="关于代码规范"></a>关于代码规范</h3><p><code>htree</code> 其实并没有遵循特定的编码规范，当前的编码风格是自己设定的一套风格，即 <code>zob</code>，同样的由于各种原因，该项目并没有进行公布。参考了部分谷歌的<a href="https://google.github.io/styleguide/jsguide.html" target="_blank" rel="noopener">JS 编码风格</a>以及一些当前项目常用的 <a href="https://eslint.org/" target="_blank" rel="noopener">ESLint</a> 规则。</p>
<h3 id="参考项目"><a href="#参考项目" class="headerlink" title="参考项目"></a>参考项目</h3><p>所谓前人栽树，后人乘凉，在完成 <code>htree</code> 这个项目的过程中，遍寻了大量的资料。</p>
<p>命令行代码主要是仿照 <a href="https://github.com/chjj/marked" target="_blank" rel="noopener">marked</a> 项目下的 <code>bin/marked</code> 来编写的。该项目也是已经长久搁置的 <code>zmd</code> 项目的核心参考资源。原本在实现命令行参数的读取的时候要采用某些依赖，比如 <a href="https://github.com/yargs/yargs" target="_blank" rel="noopener">yargs</a> 和 <a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">commander.js</a>，但后来心想，干脆就自己尝试编写纯粹的命令行读取方法吧，就写成了现在这个样子的了。</p>
<p><code>nodejs.org</code> 的官网上的 <a href="https://nodejs.org/api/" target="_blank" rel="noopener">API 文档</a>也提供了不少解决方案，主要是文件读取与写入方面的。</p>
<hr>
<p><code>htree</code> 项目的名字来源，看起来是 <code>h</code> + <code>tree</code> 的组合，粗看之下不会有人知道 <code>h</code> 代表了什么，但是我想要说的是其实这个是一个名字的谐音。嗯，是的，文本到底就结束了，希望后续能做制作一些方便使用的工具，这样也比较符合清风工具的总纲：简易、实用。</p>
]]></content>
    
    <summary type="html">
    
      本文是针对作者开发的一款命令行工具 htree 的介绍，讲述为什么要制作这样的一个工具，以及中途碰到的问题和相应的一些解决方案，权当是一个 node 开发入门的演练。在这期间也加深了对模块化与命令行工具编写的理解，将这些分享出来，与大家分享自己的一些心得。
    
    </summary>
    
      <category term="Node" scheme="https://xovel.cn/categories/node/"/>
    
    
      <category term="npm" scheme="https://xovel.cn/tags/npm/"/>
    
      <category term="tree" scheme="https://xovel.cn/tags/tree/"/>
    
      <category term="htree" scheme="https://xovel.cn/tags/htree/"/>
    
      <category term="node" scheme="https://xovel.cn/tags/node/"/>
    
      <category term="CLI" scheme="https://xovel.cn/tags/CLI/"/>
    
  </entry>
  
  <entry>
    <title>URLSearchParams 简介</title>
    <link href="https://xovel.cn/article/url-search-params.html"/>
    <id>https://xovel.cn/article/url-search-params.html</id>
    <published>2017-09-11T23:52:10.000Z</published>
    <updated>2017-09-11T17:35:47.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文根据 <code>URLSearchParams</code> 的<a href="https://url.spec.whatwg.org/#urlsearchparams" target="_blank" rel="noopener">官方规范文档</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener">MDN 文档</a>整理而成。</p>
</blockquote>
<p>URLSearchParams 是一个 WEB 接口，它定义了一些方法来处理 URL 的查询字符串。</p>
<p>构造函数 <code>URLSearchParams()</code> 返回一个 URLSearchParams 对象，这个对象没有特别的属性，也不继承任何方法。</p>
<p>URLSearchParams 的构造实例的方法如下：</p>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a><code>append</code></h3><p>插入一个新的搜索参数。该方法接受两个参数，无返回值，调用形式为 <code>URLSearchParams.append(name, value)</code>，<code>name</code> 为插入搜索参数的键名，<code>value</code> 为对应的值。</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a><code>delete</code></h3><p>删除指定名称的<strong>所有</strong>搜索参数。接受一个参数 <code>name</code> 即要删除的键值名称，无返回值。</p>
<h3 id="entries"><a href="#entries" class="headerlink" title="entries"></a><code>entries</code></h3><p><strong>不同于</strong> <code>Object.entries</code>，这里的 <code>entries</code> 方法会返回一个 <code>iterator</code>，可以遍历所有键值对的对象。每一个键值对均为 <code>USVString</code> 对象。</p>
<blockquote>
<ul>
<li>iterator 是迭代协议 Iterator 对象的实例。</li><li><code>entries</code> 方法通常在 <code>Web Workers</code> 中使用。</li><li><code>USVString</code> 为 unicode 标量值（unicode scalar values）。</li></ul>
</blockquote>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a test URLSearchParams object</span></span><br><span class="line"><span class="keyword">var</span> searchParams = <span class="keyword">new</span> URLSearchParams(<span class="string">"key1=value1&amp;key2=value2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display the key/value pairs</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> pair <span class="keyword">of</span> searchParams.entries()) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(pair[<span class="number">0</span>]+ <span class="string">', '</span>+ pair[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h3><p>获取指定搜索参数的第一个值。</p>
<h3 id="getAll"><a href="#getAll" class="headerlink" title="getAll"></a><code>getAll</code></h3><p>获取指定搜索参数的所有值。返回一个数组。</p>
<h3 id="has"><a href="#has" class="headerlink" title="has"></a><code>has</code></h3><p>判断是否存在指定的搜索参数。</p>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a><code>keys</code></h3><p>返回 iterator 对象，包含了键/值对的所有键名。其他说明与上面的 <code>entries</code> 一样。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h3><p>设置指定搜索参数对应的值。接受的参数跟 <code>append</code> 中的一样，如果存在多个搜索参数对应的值，则删除其他所有值。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a><code>sort</code></h3><p>按键名排序。排序规则为按键名的 <code>unicode</code> 码点，该规则是稳定排序，对相等的键值的相对顺序不做变更。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><code>toString</code></h3><p>返回一个字符串，由所有搜索参数组成的字符串，可以直接用在 URL 上。</p>
<h3 id="values"><a href="#values" class="headerlink" title="values"></a><code>values</code></h3><p>返回 iterator 对象，包含了键/值对的所有值。其他说明与上面的 <code>entries</code> 和 <code>keys</code> 一样。</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h3><p>扩展方法，提供接近于数组 forEach 的遍历方式，<del>但它并不是一个数组，也不是一个类数组</del>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchParams.forEach(<span class="function">(<span class="params">...args</span>)=&gt;</span><span class="built_in">console</span>.log(args))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码中，<code>args</code> 依次为键名、值、对应的 searchParam。</p>
</blockquote>
<p><em>参考资料</em>：</p>
<ul>
<li><a href="https://url.spec.whatwg.org/#urlsearchparams" target="_blank" rel="noopener">URL Standard</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener">URLSearchParams - Web APIs | MDN</a></li><li><a href="https://nodejs.org/api/url.html#url_class_urlsearchparams" target="_blank" rel="noopener">URL | Node.js v8.4.0 Documentation</a></li><li><a href="http://caniuse.com/#feat=urlsearchparams" target="_blank" rel="noopener">Can I use - Feature: URLSearchParams</a></li></ul>
]]></content>
    
    <summary type="html">
    
      本文简单介绍一下 URLSearchParams。
    
    </summary>
    
      <category term="开发" scheme="https://xovel.cn/categories/dev/"/>
    
      <category term="文档" scheme="https://xovel.cn/categories/dev/docs/"/>
    
    
      <category term="web" scheme="https://xovel.cn/tags/web/"/>
    
      <category term="URLSearchParams" scheme="https://xovel.cn/tags/URLSearchParams/"/>
    
  </entry>
  
  <entry>
    <title>十个教育家</title>
    <link href="https://xovel.cn/article/10-educationists.html"/>
    <id>https://xovel.cn/article/10-educationists.html</id>
    <published>2017-08-27T17:24:44.000Z</published>
    <updated>2017-09-12T23:40:56.436Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍十个古今中外的教育家。</p>
<a id="more"></a>
<blockquote>
<p>原本没有想要做这样一篇文章，但是契机到了，一方面是因为自己最近从事的工作是教育方面的，对于一些教育方面的认知不够；另一个方面的原因是自己在意的一些人和事近期的动态都在表明，是时候好好了解一下古今中外相关教育界的代表人物了。</p>
</blockquote>
<p>那么，我们就开始吧。</p>
<h3 id="孔子"><a href="#孔子" class="headerlink" title="孔子"></a>孔子</h3><p>作为有着 <code>至圣</code> 之称的儒家学派创始人，孔子在每一个中国人心中的印象都不可磨灭，我们从丫丫学语开始就在接触着孔子的教诲。</p>
<p>孔子在教育界领域也是鼎鼎大名，这主要体现在下面四个方面：</p>
<ol>
<li>《论语》。由孔子弟子及后人编纂的这一部《论语》是四书五经中的代表，是孔子与其子弟对话的浓缩精炼。诸多脍炙人口的名句至今读来仍然是掷地有声，发生深省。</li><li>“有教无类”、“不愤不启不悱不发”、“学而不思则罔，思而不学则殆”的教育思想。</li><li>在教学原则方面崇尚启发性教学和因材施教。</li><li>探索出典型的教学过程：学 - 思 - 行。</li></ol>
<p>孔子对教育的认知在当时是极为先明的，其创立的儒学思想对中国和世界都有着深远的影响。</p>
<h3 id="孟子"><a href="#孟子" class="headerlink" title="孟子"></a>孟子</h3><p>“亚圣”孟轲，中国另一位伟大的思想家、教育家，儒家学派代表人物，与孔子并称“孔孟”。</p>
<p>在《孟子·尽心上》，“教育”一词被最早提及。推崇的教育理念是内发论，认为教育的目的与 17 世纪提出的“个人本位论”如出一辙。</p>
<blockquote>
<p>内发论，强调人的身心发展的力量主要源于人自身的内在需要，身心发展的顺序是由身心成熟机制决定的。</p>
<p>个人本位论，主张以个人为本位，根据个人发展的需要确定教育目的和进行教育的一种理论。</p>
</blockquote>
<p>孟子认为人性本善，万物皆备于我心，是仁义礼智四性的根源，人只要善于修身养性，向内寻求，这些品质就能得到发展。</p>
<p>孟子学派崇尚的教学过程总结起来是：博学之、审问之、明辨之、慎思之、笃行之。</p>
<h3 id="朱熹"><a href="#朱熹" class="headerlink" title="朱熹"></a>朱熹</h3><p>程朱理学代表人物，南宋著名的理学家、思想家、哲学家、教育家、诗人，有“朱子”之称。朱熹的理学思想对元、明、清三朝影响很大，成为三朝的官方哲学，是中国教育史上继孔子后的又一人。</p>
<p>朱熹是最早使用“课程”这个词语的人，有“宽着期限，紧着课程”的理念。朱熹长期从事讲学活动，《四书集注》为其精心编撰的教材，该书也被明清两代列为科举考试的内容。</p>
<p>朱熹认为 8~15 岁为小学教育阶段，主要任务是培养“圣贤坯璞”；15 岁以后为大学教育，其任务是在“坯璞”的基础上再加“光饰”，把他们培养成国家所需要的人才。这种见解为中国古代教育思想增添了一些光鲜。</p>
<h3 id="苏格拉底"><a href="#苏格拉底" class="headerlink" title="苏格拉底"></a>苏格拉底</h3><p>苏格拉底是古希腊著名的思想家、哲学家、教学家、公民陪审员，与其学生柏拉图，以及柏拉图的学生亚里士多德并称“古希腊三贤”，是公认的西方哲学的奠基者。</p>
<p>在教学方法上，苏格拉底总结出了一套独特的方法，人们称之为“苏格拉底方法”，但他本人则称之为“产婆术”（一作助产术）。苏格拉底把教师比喻为“知识的产婆”，这一教育理论是西方最早的启发式教育，本文上面提到的孔子则是中国最早提出启发式教育的教育家（不愤不启，不悱不发）。</p>
<p>苏格拉底方法是以师生问答的形式进行，所有又称之为“问答法”。教师在教学生获得某种概念时，不是直接把这种概念告诉学生，而是先向学生提问，让学生回答；如果学生回答错了，不进行纠正而是提出另外的问题引导学生思考，从而一步一步得出正确的结论，这为启发式教育奠定了基础。直到今天，问答法仍然是一种重要的教学方法。</p>
<h3 id="柏拉图"><a href="#柏拉图" class="headerlink" title="柏拉图"></a>柏拉图</h3><p>柏拉图是古希腊伟大的哲学家、教育家，西方客观唯心主义哲学的创始人，是苏格拉底的学生，其创造的柏拉图思想、柏拉图主义、柏拉图式爱情对后世影响深远。</p>
<p>柏拉图是西方教育史上第一个提出完整的学前教育思想并建立了完整的教育体系的人。</p>
<p>柏拉图主张唯心教学，认为人的一切知识都是由天赋而来，教学的目的是为了恢复人的固有知识，教学过程即是回忆理念的过程。柏拉图反对强制灌输知识，提倡通过问答形式，提出问题揭露矛盾，然后进行分析、归纳、综合、判断，最后得出结论。</p>
<p>《理想国》（一作《共和国》）是柏拉图重要的对话体著作，包括哲学、伦理、教育、文艺、政治等内容。在这本对话录中，柏拉图以苏格拉底之口通过与其他人对话的方式设计了一个真善美相统一的政体，即可以达到公正的理想国。</p>
<h3 id="昆体良"><a href="#昆体良" class="headerlink" title="昆体良"></a>昆体良</h3><p>古罗马时期著名的律师、教育家，是教育史上发展和完善教育方法和思想的先驱。</p>
<p>昆体良主张对儿童的教育应是鼓励的，能激发他们的兴趣，并认为教学质量的关键在于教师，重视学生记忆能力的培养，提倡因材施教。</p>
<p>昆体良的教育理论和实践都以培养雄辩家为宗旨。在他退休后，著述了《雄辩术原理》（即《论演说家的教育》），这部著作是他自己约二十年教育工作的经验总结，是古希腊、古罗马教育经验的集大成者，也是西方最早的教学方法论著。</p>
<h3 id="夸美纽斯"><a href="#夸美纽斯" class="headerlink" title="夸美纽斯"></a>夸美纽斯</h3><p>17 世纪捷克伟大的民主主义教育家，西方近代教育理论的奠基者，被称为“近代教育之父”。</p>
<p>夸美纽斯受到人文主义的深刻影响，主张通过教育使人获得和谐发展，并通过教育改良社会，实现教派和民族的平等。夸美纽斯是最早的公共教育的拥护者，这中理念在其著作《大教学论》中有提出，该书也是近代第一本系统的教育学著作。</p>
<p>夸美纽斯在教育史上的另一个重要的贡献是最早从理论上详细阐述了班级授课制以及相关的学年制、学日制、考查、考试制度，是最早提出“班主任”概念的教育家。</p>
<p>夸美纽斯主张义务教育和泛智教育，“把一切知识教给一切人”，在当时的历史条件下，打破了封建主义的禁锢，加速了社会的发展。</p>
<p>夸美纽斯还提出了许多教育原则，如直观性原则、启发诱导原则、量力性原则、循序渐进原则、巩固性原则、因材施教原则等等。</p>
<h3 id="赫尔巴特"><a href="#赫尔巴特" class="headerlink" title="赫尔巴特"></a>赫尔巴特</h3><p>19 世纪德国哲学家、心理学家、教育家，是科学教育学的奠基人，“教育科学之父”。</p>
<p>反映其教育思想的代表作《普通教育学》是公认的第一部具有科学体系的教育学著作，这本书也使得教育学开始成为一门独立的科学。</p>
<p>赫尔巴特明确提出教育学的科学性问题，“教育学作为一种科学，是以实践哲学和心理学为基础的。前者说明教育的目的，后者说明教育的途径、手段与障碍。”</p>
<p>赫尔巴特主张的教育原则为教学的教育性，明确指出“不存在‘无教学的教育’这个概念，正如发过来，我不承认有任何‘无教育的教学’”，“德育问题是不能同整个教育分离开来的，而是同其他教育问题必然地、广泛深远地联系在一起的”，这极大的推进了教育理论的发展。</p>
<p>赫尔巴特将教学过程分为四个阶段：清楚、联想、系统、方法。</p>
<h3 id="杜威"><a href="#杜威" class="headerlink" title="杜威"></a>杜威</h3><p>美国哲学家、教育家，实用主义的集大成者。</p>
<p>杜威从实用主义经验论和机能心理学出发，批判了传统的学校教育，并就教育本质提出了“教育即生活”和“学校即社会”的观点。杜威认为，教育过程在它的自身意外无目的，教育的目的就在教育的过程之中。</p>
<p>教学论方面，杜威提倡“从做中学”。从“思维五步”出发，杜威认为教学过程也相应的分为五步：</p>
<ul>
<li>教师给儿童提供一个与社会生活经验相关联的情境；</li><li>使儿童有准备去应付在情境中产生的问题；</li><li>使儿童产生对解决问题的思考和假设；</li><li>儿童自己对解决问题的假设加以整理和排列；</li><li>儿童通过应用来校验这些假设。</li></ul>
<blockquote>
<p>思维五步：疑难的情境、确定疑难所在、提出解决疑难的各种假设、对这些假设进行推断、验证或者修改假设。</p>
</blockquote>
<h3 id="舒尔茨"><a href="#舒尔茨" class="headerlink" title="舒尔茨"></a>舒尔茨</h3><p>首先，这个人更多的身份应该是经济学家。当然，他并不是星巴克的创始人，他是获得 1979 年诺贝尔经济学奖的一位经济哲学家西奥多·舒尔茨。</p>
<p>西奥多·舒尔茨提出的“人力资本理论”对当代教育影响很深，并在美国第 73 届经济学年会上的演讲“人力资本投资”中证明了教育对经济发展的巨大贡献。</p>
<p>舒尔茨的人力资本理论主要观点有两个：<strong>人力资本的积累是社会经济增长的源泉</strong>和<strong>教育也是使个人收入的社会分配趋于平等的因素</strong>。</p>
<p>舒尔茨论述到教育对个人收入的影响：</p>
<ul>
<li>工资的差别主要是由所受的教育的差别引起的，教育可以提高收入的能力。</li><li>教育水平的提高会使因教育不同而产生的相对收入差别趋于减缓。</li><li>人力资本投资的增加还可以使物力资本投资和财产收入趋于下降。</li></ul>
<hr>
<p>行文到此，本文就算是完结了，没有什么要特别进行说明的。嗯，就是这样。这十个名单我也忘记了从哪里看到的了。看到的时候做了一个记录，但是上面的资料很<del>简陋</del>，我重新查阅了网络上的一些资料，并进行一番整理，于是就有了这一篇文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍十个古今中外的教育家。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://xovel.cn/categories/essay/"/>
    
    
      <category term="教育" scheme="https://xovel.cn/tags/%E6%95%99%E8%82%B2/"/>
    
      <category term="教育家" scheme="https://xovel.cn/tags/%E6%95%99%E8%82%B2%E5%AE%B6/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 2017 新特性一览</title>
    <link href="https://xovel.cn/article/es8.html"/>
    <id>https://xovel.cn/article/es8.html</id>
    <published>2017-07-21T04:41:27.000Z</published>
    <updated>2017-07-21T15:00:06.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文主要参考自 <code>2ality</code> 的文章：<a href="http://2ality.com/2016/02/ecmascript-2017.html" target="_blank" rel="noopener">ECMAScript 2017 (ES8): the final feature set</a>。部分章节会有修改，加入自己的一些理解与观点。<em>阅读本文需要有一定的 ES 基础</em>。</p>
<p>官方公告：<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">Standard ECMA-262</a>。</p>
</blockquote>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>ES6 发布的时候，引入了 <code>Promise</code> 来处理异步操作，一个常见的 Async 函数如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchJson</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url)</span><br><span class="line">  .then(<span class="function"><span class="params">request</span> =&gt;</span> request.text())</span><br><span class="line">  .then(<span class="function"><span class="params">text</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(text);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`ERROR: <span class="subst">$&#123;error.stack&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">fetchJson(<span class="string">'http://example.com/some_file.json'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">console</span>.log(obj));</span><br></pre></td></tr></table></figure>
<p>现在，使用 ES2017 中新增的关键字 <code>async</code> 和 <code>await</code>，我们可以实现以看起来像是同步的代码来处理异步的操作。如上面的代码可以写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> request = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">await</span> request.text();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(text);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Error: <span class="subst">$&#123;err.stack&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步函数还有一些变体，罗列如下：</p>
<ul>
<li>异步函数声明：<code>async function foo() {}</code></li><li>异步函数表达式：<code>const foo = async function () {};</code></li><li>异步方法定义：<code>let obj = {async foo () {}};</code></li><li>异步箭头函数：<code>const foo = async () =&gt; {};</code></li></ul>
<p>更多资料可参阅：<a href="https://github.com/tc39/ecmascript-asyncawait" target="_blank" rel="noopener">tc39/ecmascript-asyncawait: Async/await for ECMAScript</a>，<a href="http://exploringjs.com/es6/ch_generators.html#sec_co-library" target="_blank" rel="noopener">Simplifying asynchronous computations via generators (section in “Exploring ES6”)</a></p>
<h3 id="共享内存和原子"><a href="#共享内存和原子" class="headerlink" title="共享内存和原子"></a>共享内存和原子</h3><p>共享内存 <code>shared memory</code> 主要是处理并行事件对于资源调用的一种机制。</p>
<p>该功能引入一个新的低级别 <code>Atomics</code> 命名空间对象和一个 <code>Shared Array Buffer</code> 构造函数来作为高级别并发抽象的原始构建块。这样可以使得开发人员可以使用多个 <code>service worker</code> 和核心线程之间的 <code>Shared Array Buffer</code> 对象的数据。通过这种方式，可以更轻松的在 <code>worker</code> 之间进行数据共享，改善它们之间的协调性。</p>
<ul>
<li><a href="https://github.com/tc39/ecmascript_sharedmem" target="_blank" rel="noopener">tc39/ecmascript_sharedmem: Shared memory and atomics for ECMAscript</a></li><li><a href="http://2ality.com/2017/01/shared-array-buffer.html" target="_blank" rel="noopener">ES proposal: Shared memory and atomics</a></li></ul>
<h2 id="次要更新"><a href="#次要更新" class="headerlink" title="次要更新"></a>次要更新</h2><h3 id="Object-values-Object-entries"><a href="#Object-values-Object-entries" class="headerlink" title="Object.values/Object.entries"></a>Object.values/Object.entries</h3><p>对象为键值对的数据结构时，每一个键值对都是一个 <code>entry</code>。<code>Object.entries</code> 提供将对象转换为其可枚举的每一个对象的集合的方法。而 <code>Object.values</code> 提取出对象中可枚举的字符串键值属性的所有值。</p>
<p><code>Object.values</code> 跟 <code>Object.keys</code> 功能类似。</p>
<p>举个例子，有一个这样的对象：<code>foo = {a: 1, b: 2, c: 3};</code>，上面提到的三个方法的结果分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; foo = &#123;a:1,b:2,c:3&#125;</span><br><span class="line">&lt; Object &#123;a: 1, b: 2, c: 3&#125;</span><br><span class="line">&gt; Object.values(foo)</span><br><span class="line">&lt; (3) [1, 2, 3]</span><br><span class="line">&gt; Object.keys(foo)</span><br><span class="line">&lt; (3) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&gt; Object.entries(foo)</span><br><span class="line">&lt; (3) [Array(2), Array(2), Array(2)]0: Array(2)1: Array(2)2: Array(2)length: 3__proto__: Array(0)</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">&gt; Object.entries(&#123; one: 1, two: 2 &#125;)</span><br><span class="line">[ [ &apos;one&apos;, 1 ], [ &apos;two&apos;, 2 ] ]</span><br><span class="line"></span><br><span class="line">&gt; Object.entries(&#123; [Symbol()]: 123, foo: &apos;abc&apos; &#125;);</span><br><span class="line">[ [ &apos;foo&apos;, &apos;abc&apos; ] ]</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://2ality.com/2015/11/stage3-object-entries.html" target="_blank" rel="noopener">ES proposal: Object.entries() and Object.values()</a></li><li><a href="https://github.com/tc39/proposal-object-values-entries" target="_blank" rel="noopener">Object.values/Object.entries</a></li></ul>
<h3 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h3><p>针对 <code>String</code> 对象，引入了 <code>String Padding</code> 的规范，为字符串的处理添加了两个字符串填充的方法：<code>padStart</code> 和 <code>padEnd</code>。</p>
<h4 id="String-prototype-padStart"><a href="#String-prototype-padStart" class="headerlink" title="String.prototype.padStart"></a>String.prototype.padStart</h4><p>字符串的头部填充。接收两个参数 <code>String.prototype.padStart(maxLength, fillString=&#39; &#39;)</code>，第一个参数为填充的最大长度，第二个参数为指定填充的字符串。</p>
<p>假设我们有一个这样的操作：<code>s.padStart(n, f)</code>，s 为待填充的字符串，n 为填充后的长度，f 为填充的字符串。如果 f 的长度不够 n，则会重复使用，直到填充的长度达到了 n。如果 s 本身的长度已经超过 n 则不会进行填充。</p>
<h4 id="String-prototype-padEnd"><a href="#String-prototype-padEnd" class="headerlink" title="String.prototype.padEnd"></a>String.prototype.padEnd</h4><p>跟上面的方法类似，填充的位置在后面，其他处理方式一致。</p>
<ul>
<li><a href="https://github.com/tc39/proposal-string-pad-start-end" target="_blank" rel="noopener">ECMAScript spec proposal for String.prototype.{padStart,padEnd}</a></li></ul>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>该方法是 <code>Object.getOwnPropertyDescriptor</code> 的复数形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">    result[key] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>旨在简化对象复制的过程，它允许装饰器能够轻松的从另一个类或对象中提取出所有描述符，并将它们分配给一个新的对象。</p>
<p>由于 <code>Object.assign</code> 方法不够完美，这个是用一种吞噬行为的方式复制对象，也就是依然会出现键值覆盖的情形。</p>
<p>配合 <code>Object.create</code> 可以实现一个对象的深拷贝：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure>
<p>更多 <code>Object.getOwnPropertyDescriptor</code> 的使用场景可以参阅：<a href="http://2ality.com/2016/02/object-getownpropertydescriptors.html" target="_blank" rel="noopener">ES proposal: Object.getOwnPropertyDescriptors()</a>。</p>
<h3 id="函数的拖尾逗号"><a href="#函数的拖尾逗号" class="headerlink" title="函数的拖尾逗号"></a>函数的拖尾逗号</h3><p>以前的函数在参数定义时或者调用时，不允许出现拖尾逗号，如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  bar,</span></span></span><br><span class="line"><span class="function"><span class="params">  baz,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">foo(</span><br><span class="line">  param1,</span><br><span class="line">  param2,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在之前的版本中是错误的，但是新规范中，这可以的，拖尾逗号将被忽略，如同<strong>数组和对象字面量</strong>中的拖尾逗号。</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li><a href="http://2ality.com/2016/01/ecmascript-2016.html" target="_blank" rel="noopener">The final feature set of ECMAScript 2016 (ES7)</a></li><li><a href="https://github.com/tc39/proposals/blob/master/README.md#active-proposals" target="_blank" rel="noopener">tc39/proposals - Active proposals</a></li></ul>
]]></content>
    
    <summary type="html">
    
      近日 TC39 正式发布了 ECMAScript 的第八个版本的规范，包含了许多新特性，本文根据 2ality 的文章对这些新特性进行一个综合整理与翻译。
    
    </summary>
    
      <category term="WEB" scheme="https://xovel.cn/categories/web/"/>
    
      <category term="JS" scheme="https://xovel.cn/categories/web/js/"/>
    
    
      <category term="js" scheme="https://xovel.cn/tags/js/"/>
    
      <category term="es" scheme="https://xovel.cn/tags/es/"/>
    
      <category term="es8" scheme="https://xovel.cn/tags/es8/"/>
    
  </entry>
  
  <entry>
    <title>npm install 命令参数的一些简写方式</title>
    <link href="https://xovel.cn/article/npm-alias.html"/>
    <id>https://xovel.cn/article/npm-alias.html</id>
    <published>2017-05-19T16:32:38.000Z</published>
    <updated>2017-05-21T15:56:40.213Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 <code>npm install</code> 命令时，有许多指定参数的命令是可以进行缩写的，本文就简单梳理一下。</p>
<p><code>npm install</code>本身有一个别名，即<code>npm i</code>，可以使用这种缩写方式来运行命令，打到简化的效果。</p>
<p>以下为指定的一些命令行参数的缩写方式：</p>
<h3 id="g"><a href="#g" class="headerlink" title="-g"></a><code>-g</code></h3><p><code>--global</code>，缩写为<code>-g</code>，表示安装包时，视作全局的包。安装之后的包将位于系统预设的目录之下，一般来说</p>
<h3 id="S"><a href="#S" class="headerlink" title="-S"></a><code>-S</code></h3><p><code>--save</code>，缩写为<code>-S</code>，表示安装的包将写入<code>package.json</code>里面的<code>dependencies</code>。</p>
<h3 id="D"><a href="#D" class="headerlink" title="-D"></a><code>-D</code></h3><p><code>--save-dev</code>，缩写为<code>-D</code>，表示将安装的包将写入<code>packege.json</code>里面的<code>devDependencies</code>。</p>
<h3 id="O"><a href="#O" class="headerlink" title="-O"></a><code>-O</code></h3><p><code>--save-optional</code>缩写为<code>-O</code>，表示将安装的包将写入<code>packege.json</code>里面的<code>optionalDependencies</code>。</p>
<h3 id="E"><a href="#E" class="headerlink" title="-E"></a><code>-E</code></h3><p><code>--save-exact</code>缩写为<code>-E</code>，表示安装的包的版本是精确指定的。</p>
<h3 id="B"><a href="#B" class="headerlink" title="-B"></a><code>-B</code></h3><p><code>--save-bundle</code>缩写为<code>-B</code>，表示将安装的包将写入<code>packege.json</code>里面的<code>bundleDependencies</code>。</p>
<hr>
<blockquote>
<p><code>https://docs.npmjs.com/cli/install</code>，参考来源。</p>
</blockquote>
<hr>
<p><del>好吧，这篇算作是滥竽充数</del>，六月计划提前开始吧。做一个有内涵的技术写作者是得有多大的勇气呢？</p>
]]></content>
    
    <summary type="html">
    
      对 npm install 命令的一些参数的简写方式，这里稍作一番总结，主要是为了方便查阅。
    
    </summary>
    
      <category term="开发" scheme="https://xovel.cn/categories/dev/"/>
    
      <category term="文档" scheme="https://xovel.cn/categories/dev/docs/"/>
    
    
      <category term="npm" scheme="https://xovel.cn/tags/npm/"/>
    
      <category term="install" scheme="https://xovel.cn/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>angular函数组件简介</title>
    <link href="https://xovel.cn/article/angular-function.html"/>
    <id>https://xovel.cn/article/angular-function.html</id>
    <published>2017-05-17T14:20:40.000Z</published>
    <updated>2017-05-19T16:30:35.808Z</updated>
    
    <content type="html"><![CDATA[<p>本人前段时间对<code>angular</code>进行了一定程度的了解，<code>angular</code>系列的博文就从本篇开始吧。本文就对其提供的函数组件做一个入门级的介绍。大部分文档直接翻译自官方文档：<a href="https://docs.angularjs.org/api/ng/function" target="_blank" rel="noopener">Function components in ng</a>。</p>
<blockquote>
<p>阅读本文需要一定的<code>jQuery</code>基础。</p>
</blockquote>
<p>在函数组件中，<code>angular</code>提供了许多方便使用的功能，下面我将按照官方文档的顺序一一做介绍。</p>
<h3 id="angular-forEach"><a href="#angular-forEach" class="headerlink" title="angular.forEach"></a>angular.forEach</h3><p>遍历数组或对象。功能类似<a href="http://api.jquery.com/each/" target="_blank" rel="noopener"><code>jQuery.each</code></a>。不同的是<code>angular.forEach</code>支持传入一个上下文作为第三个参数：<code>angular.forEach(obj, iterator, [context]);</code>。</p>
<h3 id="angular-extend"><a href="#angular-extend" class="headerlink" title="angular.extend"></a>angular.extend</h3><p>扩展对象。功能类似<code>jQuery.extend</code>，不过这里是个浅复制。</p>
<h3 id="angular-merge"><a href="#angular-merge" class="headerlink" title="angular.merge"></a>angular.merge</h3><p>合并对象，深度合并，可以视为深复制。</p>
<h3 id="angular-noop"><a href="#angular-noop" class="headerlink" title="angular.noop"></a>angular.noop</h3><p>空操作，即：<code>function () {}</code>。</p>
<h3 id="angular-identity"><a href="#angular-identity" class="headerlink" title="angular.identity"></a>angular.identity</h3><p>返回第一个参数本身，用于函数式编程。</p>
<h3 id="angular-isUndefined"><a href="#angular-isUndefined" class="headerlink" title="angular.isUndefined"></a>angular.isUndefined</h3><p>判断参数是否为<code>undefined</code>。</p>
<h3 id="angular-isDefined"><a href="#angular-isDefined" class="headerlink" title="angular.isDefined"></a>angular.isDefined</h3><p>判断参数是否被定义过，与<code>angular.isUndefined</code>的结果相反。</p>
<h3 id="angular-isObject"><a href="#angular-isObject" class="headerlink" title="angular.isObject"></a>angular.isObject</h3><p>判断参数是否为对象。</p>
<blockquote>
<p>不同于<code>typeof</code>，<code>null</code>将被视为非对象，数组视为对象。</p>
</blockquote>
<h3 id="angular-isString"><a href="#angular-isString" class="headerlink" title="angular.isString"></a>angular.isString</h3><p>判断参数是否为字符串。</p>
<h3 id="angular-isNumber"><a href="#angular-isNumber" class="headerlink" title="angular.isNumber"></a>angular.isNumber</h3><p>判断参数是否为数组，包括<code>NaN</code>、<code>+Infinity</code>以及<code>-Infinity</code>。</p>
<h3 id="angular-isDate"><a href="#angular-isDate" class="headerlink" title="angular.isDate"></a>angular.isDate</h3><p>判断参数是否是一个日期对象。</p>
<h3 id="angular-isArray"><a href="#angular-isArray" class="headerlink" title="angular.isArray"></a>angular.isArray</h3><p><code>Array.isArray</code>的别名，判断是否为数组。</p>
<h3 id="angular-isFunction"><a href="#angular-isFunction" class="headerlink" title="angular.isFunction"></a>angular.isFunction</h3><p>判断是否为函数。</p>
<h3 id="angular-isElement"><a href="#angular-isElement" class="headerlink" title="angular.isElement"></a>angular.isElement</h3><p>判断是否为<code>DOM</code>元素或者<code>jQuery</code>元素。</p>
<h3 id="angular-copy"><a href="#angular-copy" class="headerlink" title="angular.copy"></a>angular.copy</h3><p>复制对象或数组，深复制。</p>
<h3 id="angular-equals"><a href="#angular-equals" class="headerlink" title="angular.equals"></a>angular.equals</h3><p>判断两个参数是否相等。</p>
<p>符合以下条件之一的均视为相等：</p>
<ul>
<li>通过严格等于<code>===</code>的判断</li><li>对象的类型一样并且其所有属性通过<code>angular.equals</code>判断均相等</li><li>两者均为<code>NaN</code></li><li>两者为正则表达式，并且其表达式相等</li></ul>
<h3 id="angular-bind"><a href="#angular-bind" class="headerlink" title="angular.bind"></a>angular.bind</h3><p>对函数进行绑定对象。<code>angular.bind</code>的参数形式类似函数的<code>call</code>方法。</p>
<p>通常用于偏函数和柯里化。</p>
<h3 id="angular-toJson"><a href="#angular-toJson" class="headerlink" title="angular.toJson"></a>angular.toJson</h3><p>转为<code>JSON</code>风格的字符串。这个过程可以称之为序列化。</p>
<h3 id="angular-fromJson"><a href="#angular-fromJson" class="headerlink" title="angular.fromJson"></a>angular.fromJson</h3><p>将一个<code>JSON</code>字符串还原，即反序列化。</p>
<h3 id="angular-bootstrap"><a href="#angular-bootstrap" class="headerlink" title="angular.bootstrap"></a>angular.bootstrap</h3><p>手动启动<code>AngularJS</code>的应用程序。</p>
<h3 id="angular-reloadWithDebugInfo"><a href="#angular-reloadWithDebugInfo" class="headerlink" title="angular.reloadWithDebugInfo"></a>angular.reloadWithDebugInfo</h3><p>以调试模式重载当前的应用程序。</p>
<h3 id="angular-injector"><a href="#angular-injector" class="headerlink" title="angular.injector"></a>angular.injector</h3><p>注入器的声明与使用。详情可参阅：<a href="https://docs.angularjs.org/guide/di" target="_blank" rel="noopener">dependency injection</a></p>
<h3 id="angular-element"><a href="#angular-element" class="headerlink" title="angular.element"></a>angular.element</h3><p>以<code>jQuery</code>风格包裹<code>DOM</code>元素或者<code>HTML String</code>。如果未引入<code>jQuery</code>，则采用<code>angular</code>自带的<code>jqLite</code>简化版。<code>jqLite</code>提供常见的<code>jQuery API</code>，可以满足大部分的情况。</p>
<h3 id="angular-module"><a href="#angular-module" class="headerlink" title="angular.module"></a>angular.module</h3><p><code>angular</code>的核心，用于声明或者获取模块。</p>
<h3 id="angular-errorHandlingConfig"><a href="#angular-errorHandlingConfig" class="headerlink" title="angular.errorHandlingConfig"></a>angular.errorHandlingConfig</h3><p>错误处理的配置。</p>
<hr>
<p>至此，<code>angular</code>自带的函数组件就梳理完毕了。更多详细的介绍，就请诸君自行查阅相关文档了。</p>
<p>接下来的空余时间里面，将会逐步针对<code>angular</code>里面的知识点做一个全面的介绍。</p>
<blockquote>
<p>通常来说，本系列博文对应的<code>angular</code>的版本为<code>1.6.x+</code>。</p>
</blockquote>
<hr>
<p>部分函数，诸如<code>angular.lowercase</code>，<code>angular.uppercase</code>已经被废弃，故此这里也不再列出。</p>
]]></content>
    
    <summary type="html">
    
      本文为针对AngularJS中的自带的函数组件的简要介绍。
    
    </summary>
    
      <category term="WEB" scheme="https://xovel.cn/categories/web/"/>
    
      <category term="JS" scheme="https://xovel.cn/categories/web/js/"/>
    
    
      <category term="angular" scheme="https://xovel.cn/tags/angular/"/>
    
      <category term="function" scheme="https://xovel.cn/tags/function/"/>
    
      <category term="components" scheme="https://xovel.cn/tags/components/"/>
    
      <category term="angularjs" scheme="https://xovel.cn/tags/angularjs/"/>
    
  </entry>
  
  <entry>
    <title>浅谈英文的缩写</title>
    <link href="https://xovel.cn/article/abbreviation.html"/>
    <id>https://xovel.cn/article/abbreviation.html</id>
    <published>2017-05-07T14:42:52.000Z</published>
    <updated>2017-05-07T16:30:30.759Z</updated>
    
    <content type="html"><![CDATA[<p>最近对一些英文单词的发音，有一些困惑，比如<code>APP</code>的发音，有些人念标准发音<code>æp</code>，有些人则念作按单字母一一念出。这里我们不讨论到底哪一种念法更为妥帖，相反的，我倒是对<code>APP</code>这种缩写方式产生了兴趣，那么，本篇文章就对英文缩写词做一个简单的梳理吧。</p>
<a id="more"></a>
<h3 id="缩写词的类型"><a href="#缩写词的类型" class="headerlink" title="缩写词的类型"></a>缩写词的类型</h3><p>通常，英文的缩写的方式有很多种，本文讲述几个常见的吧。</p>
<h4 id="截短"><a href="#截短" class="headerlink" title="截短"></a>截短</h4><blockquote>
<p><code>Shortening</code></p>
</blockquote>
<p>简单粗暴，就是直接从单词或者短语中截取能够代表核心意思的片段。</p>
<ul>
<li>缩写这个词本身<code>abbreviation</code>，其缩写为<code>abbr</code>。</li><li>编程领域经常会碰到的<code>sync</code>和<code>async</code>（同步和异步），就是<code>synchronous</code>和<code>asynchronous</code>的缩写。</li><li>举一个冷知识的例子：博客<code>blog</code>其实就是网络日志<code>weblog</code>的缩写。</li><li>翻阅英文字典，通常会发现单词的词性一栏，都是用的缩写，这个缩写方式就是截短，比如形容词<code>adj</code>/<code>adjective</code>，动词<code>v</code>/<code>verb</code>。</li></ul>
<h4 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h4><blockquote>
<p><code>Contraction</code></p>
</blockquote>
<p>跟上面提到的截短类似，收缩的方式通常省略部分字母。</p>
<ul>
<li><code>Dr.</code>是<code>Doctor</code>的缩写</li><li><code>Mr.</code>是<code>Mister</code>的缩写</li></ul>
<p>如果是短语中出现这样的情形，通常会使用单引号<code>&#39;</code>来替换被省略的部分。</p>
<ul>
<li><code>It is me.</code> 可以缩写为<code>It&#39;s me.</code>。</li><li><code>because</code>在某些俚语中，缩写为<code>&#39;cause</code>。</li><li><code>cannot</code>缩写为<code>can&#39;t</code>。</li></ul>
<p>注意，有些词的缩写可能会变更部分字母，比如<code>example</code>的缩写是<code>eg</code>。</p>
<h4 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h4><blockquote>
<p><code>Crasis</code></p>
</blockquote>
<p>这个在英文中并不常见，其他语种，比如法语，希腊语中出现的较多。<del>嗯，这一节还是忽略掉，不做深入解释了。</del></p>
<h4 id="拼合"><a href="#拼合" class="headerlink" title="拼合"></a>拼合</h4><blockquote>
<p><code>Blend</code></p>
</blockquote>
<p>由短语中的各个单词拼合而成。</p>
<p>比如<code>smog</code>（烟雾）这个词，是由<code>smoke</code>（烟）和<code>fog</code>（雾）拼合而成；再比如<code>workaholic</code>（工作狂）是由<code>work</code>（工作）和<code>alcoholic</code>（酒鬼）拼合而成。</p>
<blockquote>
<p>这种拼合方式已经属于英文中的造字法了，更多知识请自行了解，这里不做展开。</p>
</blockquote>
<h4 id="首字母拼合"><a href="#首字母拼合" class="headerlink" title="首字母拼合"></a>首字母拼合</h4><blockquote>
<p><code>Initialism</code></p>
</blockquote>
<p>同样的简单粗暴，短语的首个单词提取出来然后拼合成一个新词。大部分地名、机构、职位、专业术语的缩写通过这种方式进行，比如<code>UK</code>、<code>FBI</code>、<code>CEO</code>、<code>UFO</code>。</p>
<h4 id="缩略词"><a href="#缩略词" class="headerlink" title="缩略词"></a>缩略词</h4><blockquote>
<p><code>Acronym</code></p>
</blockquote>
<p>跟上面提到的首字母拼合基本类似。通常来说，缩略词跟首字母拼合还是有一定细微差别的：</p>
<ul>
<li>缩略词会适当忽略掉短语中出现的一些副词，比如中国的缩写<code>PRC</code>的全称是<code>People&#39;s Republic of China</code></li><li>缩略词是根据短语或者单词的意思进行综合提取进行缩写，并不一定是首字母拼合，比如<code>HTML</code>这个缩略词的全称是<strong>H</strong>yper<strong>t</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，再比如<code>REST</code>的全称<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer。</li></ul>
<h4 id="逆缩略词"><a href="#逆缩略词" class="headerlink" title="逆缩略词"></a>逆缩略词</h4><blockquote>
<p><code>Backronym</code></p>
</blockquote>
<p>黑科技无误。先有缩写，再来定义全称。</p>
<h3 id="缩写后的发音"><a href="#缩写后的发音" class="headerlink" title="缩写后的发音"></a>缩写后的发音</h3><p>缩略词会尽可能按照重新组装后的单词进行发音，比如<code>JPEG</code>（<strong>J</strong>oint <strong>P</strong>hotographic <strong>E</strong>xperts <strong>G</strong>roup）这个缩写词，读作<code>[ˈdʒeˌpɛɡ]</code>（美式发音，下同）。</p>
<p>有些发音还有点特别，比如<code>OS X</code>，读作<code>[ˈmæk ˌoʊ ˌɛs ˈtɛn]</code>，<code>IEEE</code>读作<code>I triple E</code>。</p>
<blockquote>
<p>对于缩略出来的词没法读的时候，直接按字母念就好了。</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Abbreviation" target="_blank" rel="noopener">Abbreviation - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Acronym" target="_blank" rel="noopener">Acronym - Wikipedia</a></li><li><a href="https://www.thoughtco.com/what-is-abbreviation-1689046" target="_blank" rel="noopener">What Is an Abbreviation?</a></li></ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对一些英文单词的发音，有一些困惑，比如&lt;code&gt;APP&lt;/code&gt;的发音，有些人念标准发音&lt;code&gt;æp&lt;/code&gt;，有些人则念作按单字母一一念出。这里我们不讨论到底哪一种念法更为妥帖，相反的，我倒是对&lt;code&gt;APP&lt;/code&gt;这种缩写方式产生了兴趣，那么，本篇文章就对英文缩写词做一个简单的梳理吧。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://xovel.cn/categories/essay/"/>
    
    
      <category term="abbreviations" scheme="https://xovel.cn/tags/abbreviations/"/>
    
      <category term="abbr" scheme="https://xovel.cn/tags/abbr/"/>
    
  </entry>
  
  <entry>
    <title>Brackets的使用与emmet插件安装的一个问题</title>
    <link href="https://xovel.cn/article/brackets-emmet.html"/>
    <id>https://xovel.cn/article/brackets-emmet.html</id>
    <published>2017-04-04T14:51:51.000Z</published>
    <updated>2017-04-04T15:01:57.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章来自于本博客的issue，同时也记录到了个人日志的项目中去了。</p>
</blockquote>
<p><em>以下为正文</em></p>
<hr>
<p>最近决定将IDE迁移到<a href="http://brackets.io/" target="_blank" rel="noopener">brackets</a>，毕竟是adobe开发的用来替代古老臃肿的Dreamweaver的，口号就是<code>Code The Web</code>，为Web编程提供一套完善的IDE。</p>
<hr>
<p>为什么是brackets？其实是可以用sublime的，但是sublime只是一个编辑器，没有IDE的一些特性，即便是有了插件的支持，也很难与大型IDE媲美。</p>
<p>回想我用过的IDE，最开始的FrontPage，到VS，再到后来的初次全面接触前端开发使用的Dreamweaver。而后离开福建回到湖南，开始抛弃Dreamweaver，换了一种非常极端的方式：放弃了IDE，直接采用常规编辑器Notepad++、UltraEdit来进行代码的编写。那滋味其实也还好，毕竟，那个时候最IDE的要求并不高，所使用的后台语言是asp，都用不着开带着各种兼容性问题的Dreamweaver。</p>
<p>之后的正式将主要编辑器从Notepad++转移到Sublime Text 3上面来了。用了很长一段时间的Sublime Text之后被其优雅的处理代码的方式所吸引。当然这过程中间也是过诸多其他的编辑器和IDE，比如Atom，Brackets，VS2012，那个时候还是偏向于使用纯粹的编辑器的。当然Notepad++因为处理多个文件方面的优势，我也一直在使用。</p>
<p>在现在这个公司工作之后，由于项目采用的配套的IDE，也就是可以称得上是超级IDE的WebStorm，重心也就转移到了WebStorm上面了。经过这么三四个月的使用，发现虽然功能强大，但是我依然觉得繁琐，电脑性能问题，并不容易很好的支持超大项目的处理，这个时候Sublime的优势再一次得到展现，处理大量文件毫不费力。</p>
<p>我试图将IDE改成Atom，毕竟这东西是github自家产物，但却不知道为何我迟迟没有进行这一项操作。我想我应该总有一天会使用这一款颇受好评的代码编辑工具的吧。vim这个应该也是差不多，因为现在并没有过多的接触后台操作，也不太习惯纯粹的命令行操作方式，希望以后能有机会成为传说中的vim重度依赖者吧。现阶段的我最多就是在bash里面运行几个简单的命令。</p>
<hr>
<p>之前也不知道为什么，我写markdown的工具都是打开的brackets，这个跟之前sublime的markdown插件的预览带进了巨坑是有一定关系的，至今不想再跳进去，索性就换了个编辑markdown的工具，挑来挑去，最后就是选择了brackets，仅仅是因为其界面的优雅。</p>
<p>其实，现阶段的我依然是各路编辑器和IDE混用的，因为有时候同一个项目要被各种查看，一个IDE并不能胜任，于是就出现了我同时打开了WebStorm、Atom、Brackets、Notepad++、Sublime，甚至还搬出了多年不再使用的UltraEdit，是的，它们同时打开了同一个项目。我都不敢想象为什么我会变得如此疯狂。</p>
<p>既然是要采用Brackets作为近阶段的IDE，那么就安装几个插件来让它如虎添翼吧。官方推荐的插件，我安装了几个自己认为重要的，现在我自己的电脑上的Brackets插件的安装情况大概是这个样子的：</p>
<ul>
<li><code>brackets-beautify</code>，官方推荐，代码美化工具，<strong>是的，格式化之后的代码很美！</strong></li><li><code>brackets-display-shortcuts</code>，显示快捷键列表的插件，安装好之后在帮助菜单里面执行，就可以看到当前所有的快捷键了。</li><li><code>brackets-emmet</code>，是的，这就是本文要提到的核心插件，一个快速写HTML代码的工具，那速度绝对快的飞起。</li><li><code>brackets-indent-guides</code>，显示缩进的指示线。简单又粗暴，绝对是深度依赖者的必装插件。</li><li><code>brackets-minimap</code>，当初是因为什么爱上了sublime？没错，就是因为有代码缩略地图。基本上现在用一款编辑工具，首先会去看看没有代码小地图工具，有的话先装起来再说。</li><li><code>pop-up-menu</code>，这是一个对编辑的工作区域内的右键菜单进行提升的插件，增加了一些便利性操作。</li><li><code>exclude-folders</code>，打开文件夹时，过滤指定文件夹的插件。过滤了<code>node_modules</code>文件夹之后，项目的打开速度得到了明显的提升。但是看不到node_modules文件夹还是总觉得有点欠缺的。</li><li><code>markdown-preview</code>，markdown预览插件。作为一个重度markdown使用者，这插件对我来说也是极好的。</li><li><code>file-icons</code>，简单粗暴，给打开的各路文件的前面显示一个图标。优雅美观说的就是这样的效果。</li><li><code>monokai-theme</code>，Sumline Text的爱好者对这个那必须是钟爱莫名的，非常精致的代码配色方案。</li><li><code>color-palette</code>，取色器，好用不解释。</li></ul>
<p>嗯，这些插件的安装其实并不是顺利，因为有<del>强大的</del>GFW的存在，悲催的brackets因为调用了aws的资源，所以有时候那速度卡的飞起，所以大部分插件我都是通过github的zip链接进行安装的。</p>
<p>安装完毕了之后，慕名已久的emmet插件一直不肯工作，这到底是为什么？</p>
<p>可能是因为疏忽大意了，一直迟迟忘记了brackets是基于HTML/JS构建出来的编辑工具，其界面上面是自带了Chrome DevTools的。为了这个问题，我几乎是找遍了brackets、emmet、stackoverflow上面的所有资源，依然是没有解决这个问题，后来又想，干脆手动安装一次，完全的纯粹的手动方式：</p>
<ol>
<li>进入brackets的插件目录，我的是win10环境，所以在<code>C:\Users\xovel\AppData\Roaming\Brackets\extensions</code>这里。</li><li>进入user文件夹，打开bash。</li><li>在bash里面执行git clone操作。</li><li>clone完成之后进入插件目录<code>brackets-emmet</code>，继续执行依赖安装操作<code>npm install</code>。</li><li>安装完毕之后会发现，目录下多了个node_modules文件夹。</li><li>进去一看，里面有两个文件夹，分别是<code>emmet</code>和<code>caniuse-db</code>。</li><li>不管那么多，重启brackets。</li></ol>
<p>很遗憾，依然没有emmet功能。</p>
<p>几经周折，我终于看到了调试里面的开发工具，于是调出F12，看看到底是什么错误导致的。</p>
<p>果不其然，在控制台里面有一行错误提示：大意是缺少一个文件，这个文件就是<code>\brackets-emmet\node_modules\emmet\lib\caniuse.json</code>，我仔细去看了一遍，确实是没有这个文件。</p>
<p>这就比较尴尬了，会不是我这样的安装方式不对？我决定到一个全新的地方使用命令行的方式从npm上安装全新的emmet，使用<code>npm install emmet</code>命令之后，我竟然又执行了<code>npm install</code>，把emmet的开发依赖给安装了，甚至还跑了<code>gulp</code>任务，结果生成了一个dist文件夹，我感觉我这么做有点走弯路了，<del>是的，确实是走弯路，弯的很厉害</del>。不过看到dist下的<code>emmet.js</code>大小有<code>1868kb</code>的时候心里还是很是震惊的。</p>
<p>依然没有看到caniuse.json，我就在想，这个名字跟上面提到的<code>caniuse-db</code>，应该是存在着某种关联的吧。果不其然，上emmet的repo上一搜，发现一个<a href="https://github.com/emmetio/emmet/pull/385" target="_blank" rel="noopener">提交记录</a>被接受了，就是提议将<code>caniuse.json</code>换成<code>caniuse-db</code>的。好家伙，这就很尴尬了。</p>
<p>既然现在的版本已经被替换掉了，那么问题就相对来说简单了，我应该只需要找到这个缺失的文件并将它放到它应该出现的位置上就可以了。于是我通过repo的tag记录依次寻找，发现从1.3.2之后，这个caniuse.json就不见了踪影。也是说从1.4.0版本开始，丢弃了caniuse.json，改为使用caniuse-db进行可用性判定。</p>
<p>于是我复制了一份json到本地目录中，然后重启brackets，甚好，<code>Emmet</code>菜单出来了。而后打开一个html文件，飞速敲下<code>div&gt;ul&gt;li</code>，然后按下<code>tab</code>，一个良好缩进展现的HTML结构跃然纸上。</p>
<p>问题解决了，但我觉得应该不止我一个人被这个问题所困扰，后来我仔细看了一下<code>brackets-emmet</code>的插件的package文件，发现里面只有一个依赖：<code>&quot;emmet&quot;: &quot;^1.3.0&quot;</code>。好家伙，竟然是<code>&quot;^1.3.0&quot;</code>！</p>
<p><code>^</code>！！</p>
<p>让我说什么好呢？这语义化的版本控制机制，应该是被npm给更改了操作规则吧。因为安装出来的版本号显示的是1.6.2，这明显不科学。</p>
<p>于是我手动将这一行代码改成了：<code>&quot;emmet&quot;: &quot;1.3.0&quot;</code>，然后将整个node_modules个删了，并在bash里面重新走了一边安装的操作，这个时候出来的结果是只安装了一个emmet了。怀着一颗激动的心，我重启了brackets，嗯，甚好，Emmet还在。</p>
<p>至此，brackets上的emmet插件算是成功解决了。</p>
<hr>
<p>总结：瞎折腾之下，获取了宝贵的经验，也算是一种收获。<del>虽然内心觉得得不偿失</del></p>
]]></content>
    
    <summary type="html">
    
      本文介绍一下自己对于brackets的一些使用的心得，罗列安装的一些的插件，并着重讲述一下emmet这款插件的安装过程出现的问题，以及其对应的解决方案。
    
    </summary>
    
      <category term="开发" scheme="https://xovel.cn/categories/dev/"/>
    
    
      <category term="brackets" scheme="https://xovel.cn/tags/brackets/"/>
    
      <category term="IDE" scheme="https://xovel.cn/tags/IDE/"/>
    
      <category term="emmet" scheme="https://xovel.cn/tags/emmet/"/>
    
      <category term="plugin" scheme="https://xovel.cn/tags/plugin/"/>
    
      <category term="editor" scheme="https://xovel.cn/tags/editor/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Semicolon Insertion</title>
    <link href="https://xovel.cn/article/javascript-semicolons.html"/>
    <id>https://xovel.cn/article/javascript-semicolons.html</id>
    <published>2017-03-29T11:47:27.000Z</published>
    <updated>2017-03-29T14:53:00.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文转自：<a href="http://inimino.org/~inimino/blog/javascript_semicolons" target="_blank" rel="noopener">~inimino/blog</a></p>
</blockquote>
<p><strong>JavaScript Semicolon Insertion</strong></p>
<p><strong>Everything you need to know</strong></p>
<p><em>Friday, May 28, 2010</em></p>
<hr>
<p>Automatic semicolon insertion is one of JavaScript’s most controversial syntactic features. There are also many misconceptions surrounding it.</p>
<p>自动插入分号是JavaScript里最具有争议的语法特性。其周围也存在许多误解。</p>
<p>Some JavaScript programmers use semicolons at the end of every statement, and some use them only where strictly required. Most do something in between, and a few even intentionally add extra semicolons as a matter of style.</p>
<p>一些JavaScript程序员会在每一个语句后面都使用分号，有一些则只在有必要的时候使用。大多数人介于两者之间，也有少数人将特意添加额外的分号作为一种风格。</p>
<p>Even if you use semicolons at the end of every statement, some constructs parse in non-obvious ways. Regardless of your preferences in semicolon usage, you must know the rules to write JavaScript professionally. If you remember a few simple rules, all of which are explained here, you will be able to understand how any program you might encounter will be parsed, and will be an expert on JavaScript automatic semicolon insertion, or ASI.</p>
<p>即便是在每一个语句后面都跟分号，一些构造器依然会不那么明显的进行解析。不顾后果的使用分号，你必须知道专业地编写JavaScript代码的规则。如果能记住本文提出的一些简单的规则，你可以更好的理解程序是如何的解析的，并且可以在JavaScript自动分号插入（或者简称为<code>ASI</code>）方面成为专家。</p>
<h3 id="Where-Semicolons-are-Allowed"><a href="#Where-Semicolons-are-Allowed" class="headerlink" title="Where Semicolons are Allowed"></a>Where Semicolons are Allowed</h3><p><strong>分号在哪里是允许的？</strong></p>
<p>In the formal language grammar given in the ECMAScript specification, semicolons are shown at the end of each kind of statement in which they can appear. Here is the do-while statement:</p>
<p>根据ECMAScript标准指出的常规的语法，分号在各种语句的后面都可以出现。这里有一个<code>do-while</code>语句：</p>
<pre><code>do Statement while ( Expression ) ;
</code></pre><p>Semicolons also appear in the grammar at the end of var statements, expression statements (such as “<code>4+4;</code>“ or “<code>f();</code>“), continue, return, and break statements, and throw and debugger statements.</p>
<p>分号也可以出现在<code>var</code>声明语句，表达式语句（诸如<code>4+4;</code>、<code>f();</code>），<code>continue</code>、<code>return</code>、<code>break</code>语句，以及<code>throw</code>和<code>debugger</code>语句。</p>
<p>The empty statement is just a semicolon by itself, and is a legal statement in JavaScript. For this reason, “<code>;;;</code>“ is a valid JavaScript program; it parses as three empty statements, and runs by doing nothing three times.</p>
<p>空语句同样可以使用分号，这在JavaScript中也是可行的。鉴于这个原因，<code>;;;</code>是有效的JavaScript程序，它会解析成三个空语句，运行时会做三次啥也不做的事情。</p>
<p>Sometimes empty statements are actually useful, at least syntactically. For example, to write an infinite loop, one can write <code>while(1);</code>, where the semicolon is parsed as an empty statement, which makes the while statement syntactically valid. If the semicolon was omitted, the while statement would not be complete, because a statement following the loop condition is required.</p>
<p>事实上，至少在语法构成方面，有时候空语句是很有用的。举个例子，编写一个无限循环，可以这么写：<code>while(1);</code>，分号将被解析成一个空语句，这样可以使<code>while</code>语句的语法变得有效。如果省略分号，这个<code>while</code>语句就不完整了，因为后续的循环体是必须的。</p>
<p>Finally, semicolons appear in for loops of the form <code>for ( Expression ; Expression ; Expression ) Statement</code>, and of course they may appear as themselves inside strings and regular expression literals.</p>
<p><del>太长，任性不翻译了</del></p>
<h3 id="Where-Semicolons-May-be-Omitted"><a href="#Where-Semicolons-May-be-Omitted" class="headerlink" title="Where Semicolons May be Omitted"></a>Where Semicolons May be Omitted</h3><p>In the formal grammar used in the ECMAScript specification, the semicolons are included, as described above. However, the specification prose then gives rules which describe how the actual parsing differs from the formal grammar. These are described as though semicolons are inserted into the token stream while parsing, though this is just a specification convenience; in practice, parsers do not need to generate fake semicolon tokens, but can instead regard semicolons as optional in specific places in the grammar (for an example see <a href="http://boshi.inimino.org/3box/PanPG/grammars/ECMAScript_5.peg" target="_blank" rel="noopener">this parser expression grammar for ECMAScript</a>, particularly the Statement, EOS, EOSnoLB, and SnoLB rules). Where the specification says that a semicolon is inserted, this simply means that the statement currently being parsed is ended.</p>
<p>These semicolon insertion rules are specified in section 7.9 of <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf" target="_blank" rel="noopener">ECMA-262 [pdf]</a>.</p>
<p>The section gives three basic rules, followed by two exceptions.</p>
<p>The rules are:</p>
<ol>
<li>When the program contains a token that is not allowed by the formal grammar, then a semicolon is inserted if (a) there is a line break at that point, or (b) the unexpected token was a closing brace.</li><li>When the end of a file is reached, if the program cannot be parsed otherwise, then a semicolon is inserted.</li><li>When a “restricted production” is encountered and contains a line terminator in a place where the grammar contains the annotation “[no LineTerminator here]”, then a semicolon is inserted.</li></ol>
<p>Approximately, these rules state that a statement can be terminated without a semicolon either (a) before a closing brace, (b) at the end of the program, or (c) when the next token cannot be parsed otherwise, and furthermore that there are certain places in the grammar in which, if a line break appears, it terminates the statement unconditionally. The practical effects of these rules are discussed below.</p>
<p>The exceptions are that a semicolon is never inserted as part of the header of a for loop of the form <code>for ( Expression ; Expression ; Expression ) Statement</code>, and a semicolon is never inserted if it would be parsed as an empty statement.</p>
<p>What do these rules and exceptions mean in practice?</p>
<p>Firstly, a semicolon is optional only where there is a line break, a closing brace, or the end of the program. Semicolons are not optional between statements appearing on the same line. Additionally, a semicolon is not implied at the end of a line if the first token of the subsequent line can be parsed as part of the same statement.</p>
<p><code>42; &quot;hello!&quot;</code> is a valid program, as is <code>42\n&quot;hello!&quot;</code> (with the “\n” representing an actual linebreak), but <code>42 &quot;hello!&quot;</code> is not; the linebreak triggers semicolon insertion but linear whitespace does not. Also valid is “<code>if(x){y()}</code>“. Here “<code>y()</code>“ is an expression statement, which can be terminated by a semicolon, but since the next token is a closing brace, the semicolon is optional even though there is no linebreak.</p>
<p>The two exceptions, for loops and empty statements, can be demonstrated together:</p>
<pre><code>for (node=getNode();
     node.parent;
     node=node.parent) ;
</code></pre><p>This for loop takes the parent of a node repeatedly until a node is reached which has no parent. All of this is done in the header of the for loop, so we have nothing left for the statement inside the for loop to do. However, the for loop syntax requires a statement, so we use an empty statement. Even though all three of the semicolons in this example appear at the end of a line, all three of them are required, since a semicolon is never inserted in a for loop header or to create an empty statement.</p>
<h3 id="Restricted-Productions"><a href="#Restricted-Productions" class="headerlink" title="Restricted Productions"></a>Restricted Productions</h3><p>Restricted productions are those in which a line break cannot appear in a particular position, so if a line break appears there, it will prevent the program from parsing in that way, though it may still parse another way.</p>
<p>There are five restricted productions in the grammar, they are the postfix operators <code>++</code> and <code>--</code>, continue statements, break statements, return statements, and throw statements. Break and continue statements have an optional identifier which may be used to break or continue a particular labelled loop in which the statement appears. If this feature is used, the identifier must be used on the same line as the <code>break</code> or <code>continue</code> token. The following is a valid program:</p>
<pre><code>var c,i,l,quitchars
quitchars=[&apos;q&apos;,&apos;Q&apos;]
charloop:while(c=getc()){
    for (i=0; i&lt;quitchars.length; i++){
        if (c==quitchars[i]) break charloop
    }
    /* ... more code to handle other characters here ... */
}
</code></pre><p>If <code>getc()</code> reads a character from an input device and returns it, then the program will read characters, test each one of them to see if it is in <code>quitchars</code>, and if it is, break the input loop. Note that the labelled break statement is necessary to escape from the outer while loop and not only the inner for loop. The following program, differing only in whitespace, will also parse, but will not give the same result:</p>
<pre><code>var c,i,l,quitchars
quitchars=[&apos;q&apos;,&apos;Q&apos;]
charloop:while(c=getc()){
    for (i=0; i&lt;quitchars.length; i++){
        if (c==quitchars[i])
            break
                charloop
    }
    /* ... more code to handle other characters here ... */
}
</code></pre><p>Specifically, in the latter case, the <code>charloop</code> token is not part of the break statement. Since the break statement is restricted, the linebreak at that position terminates the break statement. The <code>charloop</code> token simply parses as a reference to a charloop variable, which will never be reached, and the break statement will terminate the inner loop, not the outer loop as was intended.</p>
<p>Here are examples illustrating the other four restricted productions:</p>
<pre><code>// PostfixExpression :                                            
//              LeftHandSideExpression [no LineTerminator here] ++
//              LeftHandSideExpression [no LineTerminator here] --
var i=1;
i
++;
</code></pre><p>This is a parse error, it does not parse as “<code>i++</code>“. A line terminator cannot appear before the postfix increment or decrement operator, so a “<code>++</code>“ or “<code>--</code>“ token at the start of the line will never parse as part of the preceding line.</p>
<pre><code>i
++
j
</code></pre><p>This is not a parse error: it parses as “<code>i; ++j</code>“ The pre-increment and -decrement expressions are not restricted, so a linebreak can occur between the “<code>++</code>“ or “<code>--</code>“ token and the expression which it modifies.</p>
<pre><code>// ReturnStatement: return [no LineTerminator here] Expressionopt ;
return
  {i:i, j:j}
</code></pre><p>This parses as an empty return statement, followed by an expression statement which will never be reached. The following all parse as intended:</p>
<pre><code>return {
  i:i, j:j}
return (
  {i:i, j:j})
return {i:i
       ,j:j}
</code></pre><p>Note that return statements can contain linebreaks within the expression, just not between the <code>return</code> token and the start of the expression. When semicolons are intentionally omitted, it is convenient that the return statement is a restricted production, as it allows the programmer to write an empty return statement without accidentally returning the value of the next line:</p>
<pre><code>function initialize(a){
  // if already initialized, do nothing
  if(a.initialized) return
  a.initialized = true
  /* ... initialize a ... */
}
</code></pre><p>Continue and throw statements are similar to break and return:</p>
<pre><code>continue innerloop // correct

continue
    innerloop;     // incorrect

// ThrowStatement : throw [no LineTerminator here] Expression ;
throw                                          // parse error
  new MyComplexError(a, b, c, more, args);
// Unlike the return, break, and continue statements, 
// the expression after &quot;throw&quot; is not optional, 
// so the above will not parse at all.
throw new MyComplexError(a, b, c, more, args); // correct
throw new MyComplexError(
    a, b, c, more, args);                      // also correct
// Any variation with &apos;new&apos; and &apos;throw&apos; on the same line is correct.
</code></pre><p>Note that indentation has no effect in parsing ECMAScript programs, but the presence or absence of line breaks does. Therefore, any tool that processes JavaScript source code may remove leading whitespace from lines (outside of string literals!) without changing the semantics of the program, but line breaks cannot be indiscriminately removed or replaced with spaces or semicolons. A minification tool that changes the semantics of valid programs is a broken tool, and the only way to write a correct tool is to use a complete and correct parser.</p>
<p>Line breaks following <code>return</code>, <code>break</code>, and <code>continue</code> or preceding <code>++</code> and <code>--</code> tokens can affect parsing. Since the productions above are the only restricted productions in the language, this implies that whitespace including linebreaks can be freely added anywhere else as desired to improve readability. In particular the logical, arithmetic, and string concatenation operators, the ternary or conditional operator, member access using the dot or bracket notations, function calls, and while loops, for loops, switch statements, and the rest of the control structures, can all be written with linebreaks freely used throughout.</p>
<p>As the specification says:</p>
<blockquote>
<p>The resulting practical advice to ECMAScript programmers is: A postfix <code>++</code> or <code>--</code> operator should appear on the same line as its operand. An Expression in a return or throw statement should start on the same line as the return or throw token. A Identifier in a break or continue statement should be on the same line as the break or continue token.</p>
</blockquote>
<p>The most commonly cited programmer error related to restricted productions is to put the return value on the line after the <code>return</code> token, especially common when the returned value is a large object or array literal or multiline string. Line break errors with postfix operators, break, continue, and throw statements are rarely seen in practice, for the simple reason that the erroneous line breaks look unnatural to most programmers and so are unlikely to be written.</p>
<p>The final subtlety of ASI arises from the first rule, which requires that the program contain a token which is not allowed by the formal grammar, before a semicolon will be inserted. When writing code with optional semicolons omitted, it is important to keep this rule in mind so that required semicolons are not inadvertently omitted as well. This rule is what makes it possible to extend statements across multiple lines, as in the following examples:</p>
<pre><code>return obj.method(&apos;abc&apos;)
          .method(&apos;xyz&apos;)
          .method(&apos;pqr&apos;)

return &quot;a long string\n&quot;
     + &quot;continued across\n&quot;
     + &quot;several lines&quot;

totalArea = rect_a.height * rect_a.width
          + rect_b.height * rect_b.width
          + circ.radius * circ.radius * Math.PI
</code></pre><p>The rule considers only the first token of the following line. If that token can parse as part of the statement, then the statement is continued (even if parsing fails a little further on: the language syntax is designed to only require one token of lookahead in the parser). If the first token cannot extend the statement, then a new statement begins (which the spec describes by saying a semicolon is inserted).</p>
<p>The potential for error arises whenever there is a pair of statements A and B such that both A and B are valid statements standing alone, but the first token of B can also be accepted as an extension of A. In such cases, if a semicolon is not provided, the parser will not parse B as a separate statement, and will either reject the program or parse it in a way that the programmer did not intend. Thus when semicolons are omitted, the programmer must beware any such statement pair separated by a linebreak as:</p>
<pre><code>A
B
</code></pre><p>Where B begins with a token that would be accepted by the parser if it had appeared at the end of line A.</p>
<p>The majority of JavaScript statements begin with an identifier, and the majority of the remainder begin with a keyword such as “var”, “function”, or “if”. For any such statement B beginning with a keyword or identifier, as well as any beginning with a string or number literal, there is no valid complete statement A such that the first token of B would be accepted by the parser as extending A. (The verification of this from the grammar is left as an exercise for the reader.)</p>
<pre><code>A
function f(x){return x*x}

// for any statement A, without any terminating semicolon,
// all of these examples will parse as intended

A
f(7)

A
&quot;a string&quot;.length
</code></pre><p>Unfortunately, there are five tokens that can appear both at the start of a statement, and as an extension of some complete statement A. These tokens are the open parenthesis “<code>(</code>“, open square brace “<code>[</code>“, slash or solidus “<code>/</code>“, and “<code>+</code>“ and “<code>-</code>“. Of these, the first two are problematic in practice.</p>
<p>This means it is not always the case that a line break can replace a semicolon between statements.</p>
<p>The spec gives the following example:</p>
<blockquote>
<pre><code>a = b + c
(d + e).print()
</code></pre><p>is not transformed by automatic semicolon insertion, because the parenthesised expression that begins the second line can be interpreted as an argument list for a function call:</p>
<pre><code>a = b + c(d + e).print
</code></pre></blockquote>
<p>The spec goes on to suggest, “In the circumstance that an assignment statement must begin with a left parenthesis, it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion.” A more robust alternative where semicolons are intentionally omitted is to include the semicolon at the beginning of the line, directly before the token that introduces the potential ambiguity:</p>
<pre><code>a = b + c
;(d + e).print()
</code></pre><p><del>上面的代码前面有很多空格，实际上在marked工具解析的时候会忽略代码前的空格</del></p>
<p>Statements beginning with open parentheses or square braces are somewhat rare, but do arise in practice.</p>
<p>Examples involving open square braces are more common now that “functional” operations such as map, filter, and forEach are common on arrays. It is often convenient to use an array literal with a forEach call which is evaluated for its side-effects, as in the following:</p>
<pre><code>[[&apos;January&apos;,&apos;Jan&apos;]
,[&apos;February&apos;,&apos;Feb&apos;]
,[&apos;March&apos;,&apos;Mar&apos;]
,[&apos;April&apos;,&apos;Apr&apos;]
,[&apos;May&apos;,&apos;May&apos;]
,[&apos;June&apos;,&apos;Jun&apos;]
,[&apos;July&apos;,&apos;Jul&apos;]
,[&apos;August&apos;,&apos;Aug&apos;]
,[&apos;September&apos;,&apos;Sep&apos;]
,[&apos;October&apos;,&apos;Oct&apos;]
,[&apos;November&apos;,&apos;Nov&apos;]
,[&apos;December&apos;,&apos;Dec&apos;]
].forEach(function(a){ print(&quot;The abbreviation of &quot;+a[0]+&quot; is &quot;+a[1]+&quot;.&quot;) })

[&apos;/script.js&apos;
,&apos;/style1.css&apos;
,&apos;/style2.css&apos;
,&apos;/page1.html&apos;
].forEach(function(uri){
   log(&apos;Looking up and caching &apos;+uri)
   fetch_and_cache(uri)})
</code></pre><p>In cases where array literals are used for their value in an assignment expression, or are passed to a function, they will not appear as the beginning of the statement, so an opening square brace as the first token is rare, but does occur.</p>
<p>The final troublesome token is the slash, and this one can be highly counterintuitive. Consider the following example:</p>
<pre><code>var i,s
s=&quot;here is a string&quot;
i=0
/[a-z]/g.exec(s)
</code></pre><p>On lines 1-3 we set up some variables, and on line 4, it appears, we construct a regexp literal <code>/[a-z]/g</code> which will globally match a-z, and then we evaluate this regexp against the string with the exec method. Since the return value of the exec() call is not used, this code is not very useful, but we might expect it to compile. However, the slash can not only appear at the beginning of a regexp literal, but also serves as the division operator. That means that the leading slash on line 4 will actually be parsed as a continuation of the assignment statement on the previous line. The entirety of lines three and four parses as the single statement “i equals 0 divided by [a-z] divided by g.exec(s)”.</p>
<p>This issue almost never arises in practice because there is seldom a practical reason to begin a statement with a regexp literal. In the example above, the value of the exec() call would usually be passed to a function or assigned to a variable, and in either case the line would no longer begin with a slash. One possible exception is, again, with the forEach Array method, which could be usefully used on the return value of an exec() call directly.</p>
<p>The operators “<code>+</code>“ and “<code>-</code>“ can be used as unary operators, to convert a value to the Number type and in the case of “<code>-</code>“ to reverse the sign. If used at the beginning of a statement with semicolons omitted, these can be interpreted as the corresponding binary operator, as a continuation of the previous statement. Even when semicolons are intentionally omitted, this is rarely a problem, as a leading unary operator is even less likely than a regexp literal to occur as the first token of a statement (and it does not look self-contained in the way that a parenthesized expression does). As with regexps, if the programmer wanted to coerce a value to a Number, it was probably to do something with that Number value, such as assign it to a variable or pass it to a function, and in either case the unary operator would not be the first token of the statement:</p>
<pre><code>var x,y,z
x = +y;    // useful
y = -y;    // useful
print(-y); // useful
+z;        // useless
</code></pre><p>In all such cases, when semicolons are omitted, the safest practice with lines beginning with an open parenthesis or square brace is to precede the token with a semicolon on the line itself. This advice also applies in the unlikely case of statements beginning with an arithmetic operator “<code>+</code>“, “<code>-</code>“, or “<code>/</code>“. In this way, even when semicolons are not used elsewhere, the line will be protected from misparsing regardless of how the line previous to it may change over time.</p>
<h3 id="Misconceptions"><a href="#Misconceptions" class="headerlink" title="Misconceptions"></a>Misconceptions</h3><p>Many new JavaScript programmers are advised to just use semicolons everywhere, and expect that if they do not intentionally use the semicolon insertion rules, they can safely ignore the existence of this entire language feature. This is not the case, because of the restricted productions described above, notably the return statement. When becoming aware of the restricted production issue, programmers may then become overly wary of linebreaks, and avoid them even when they would increase clarity. It is best to be familiar with all the rules for ASI so as to be able to read any code regardless of how it is written, and to write code that is as clear as it can be.</p>
<p>Another misconception is that bugs in browser JavaScript engines mean that using semicolons everywhere is safer, and will protect the developer from compatibility issues between browsers. This is simply not the case. All extant browsers implement the specification correctly with regard to ASI, and any bugs that may have existed are long since lost in the mists of early Web history. There is no reason to be concerned about browser compatibility in regard to semicolon insertion: all browsers implement the same rules and they are the rules given by the spec and explained above.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Should you omit optional semicolons or not? The answer is a matter of personal preference, but should be made on the basis of informed choice rather than nebulous fears of unknown syntactical traps or nonexistent browser bugs. If you remember the rules given here, you are equipped to make your own choices, and to read any JavaScript easily.</p>
<p>If you choose to omit semicolons where possible, my advice is to insert them immediately before the opening parenthesis or square bracket in any statement that begins with one of those tokens, or any which begins with one of the arithmetic operator tokens “<code>/</code>“, “<code>+</code>“, or “<code>-</code>“ if you should happen to write such a statement.</p>
<p>Whether you omit semicolons or not, you must remember the restricted productions (return, break, continue, throw, and the postfix increment and decrement operators), and you should feel free to use linebreaks everywhere else to improve the readability of your code.</p>
<p><del>全文完</del></p>
]]></content>
    
    <summary type="html">
    
      这是一篇发表于2010年5月28日的文章，本篇为转载，讲述关于JavaScript语法中的分号方面的问题。最近关于是否要去除不必要的分号的编程风格确认的时候，遇到了一些问题，很多支持去除分号的文章都引用了这一篇文章，故此这里纯粹作一个转载。
    
    </summary>
    
      <category term="开发" scheme="https://xovel.cn/categories/dev/"/>
    
    
      <category term="js" scheme="https://xovel.cn/tags/js/"/>
    
      <category term="semicolon" scheme="https://xovel.cn/tags/semicolon/"/>
    
      <category term="asi" scheme="https://xovel.cn/tags/asi/"/>
    
  </entry>
  
  <entry>
    <title>两次婚礼纪实</title>
    <link href="https://xovel.cn/article/record-to-two-special-weddings.html"/>
    <id>https://xovel.cn/article/record-to-two-special-weddings.html</id>
    <published>2017-03-20T13:31:52.000Z</published>
    <updated>2017-03-21T15:40:47.726Z</updated>
    
    <content type="html"><![CDATA[<p>在2017年的一月份，我以伴郎的身份分别出席了两场于我而言很重要的婚礼，很早以前我说过要对这个做一个详细的记录，今天特地前来重新回忆并描述一下，也算是对自己博客复苏计划的一个引子吧。</p>
<a id="more"></a>
<p>在我的个人日记中，也稍稍做了一个简短的介绍，详情可以参加本文下方的链接进行查看<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p>
<hr>
<p>下面就开始重述吧，我会尽量回忆当时的场景。</p>
<p>先说第一场婚礼，这一场婚礼是我堂哥的婚礼。堂哥和嫂子其实很早以前就认识并相恋了，我在长沙就读大学的时候就已经见过嫂子，虽不说嫂子倾国倾城，但至少也是明艳动人。后来因为各种原因吧，我前往杭州逐梦，便失去了众位家人的联系，也就不太清楚堂哥和嫂子的发展情况。那个时候在每年过年的时候依稀听家人提起，堂哥的感情路线还是比较飘摇的，我想在辗转奔波之中堂哥与嫂子也是倍加珍惜对方了吧。</p>
<p>于是，就在今年，他们决定好了，一起步入婚姻的殿堂。</p>
<p>堂哥很早就给我打电话了，我当时自然二话不说，直接答应了堂哥的邀请。时间定在2017年的1月18日，农历的十二月二十一，据说是非常好的黄道吉日，我搜了一下日历，的确是有今日适合婚嫁的字样呢。</p>
<p>当时我已经在新公司上班了，于是我就去请了三天假，17号我就乘车回家了。当时的天气可能有一点点小雨，看起来似乎更增添了婚礼的浪漫气息。</p>
<p>18日清早，我便准备好了，直接去往了堂哥的新家，几番布置与准备，我们开始了迎亲的历程。当时堂哥的表哥也到了，我也是很久没有见到他了，上一次还是在好几年前，一转眼他的儿子都可以打酱油了。</p>
<p>早上有点蒙蒙雨，扎花车的队伍看起来也确实是有点手忙脚乱的样子。雨中扎花车，倒也别有一番韵味。</p>
<p>摄像师是我们初中同学的父亲，许久不见，他的表情依旧是那么的友善。</p>
<p>好吧，我已经忘记了到底有多少辆车子了。大队伍出发，前往嫂子的家中了。大概是开了有半个小时的样子吧，终于是到了。</p>
<p>嫂子的家距离县城其实也不算太远，我之前有以为是在我们镇里，看起来的确是我自己记错了。嫂子的家人也很友善，对我们这些接亲的人员也没有太多的为难。很有意思的一点就是，当时我们去接亲的时候，大门被锁了，当时我们不明就里，就把红包直接往里面洒了。得知真实的情况是小孩子太过于淘气任性，把门的反锁给弄坏了，外面和里面都无法打开。这就有点尴尬了，费了一番功夫总算是把门的问题给解决了。</p>
<hr>
<p><del>昨天写的内容，今天再来看，怎么都像是流水账，哈哈</del></p>
<hr>
<p>当天的接亲，等到好不容易门开了，结果新娘子却是在二楼，这着实令人尴尬，因为红包都撒了一半去了。我们自然也是二话不说，直奔二楼，然后新娘子自然是在屋里面的，我们开始推门。里面有人喊红包呢，于是我们也是积极的丢红包，依稀可以听到里面小孩子的嬉闹声，甚至开心的样子。</p>
<p>说起来撞门也没有花费太大的精力，因为里面只有三个人拦门。毕竟这个时间点，能回来的人并不会太多。</p>
<p>于是我们就算是接亲成功了，下楼一番客套，喝了点礼茶，然后就回程了。大约在十点不到的样子就回到了堂哥的新房。</p>
<p>嗯，顺便说一下堂哥的新房概况，房子面积大概是一百二十多，买的时候正直县城房价上涨的高峰阶段，然后装修是伯父亲力亲为全程督工的，总的花费应该是在15w的样子，总体效果还是蛮不错的。堂弟说他买了二十多个排插，然后全被用掉了，所以他总是感慨，房子里面到处是插座。</p>
<p>或许是我们太过于远离传统规矩，一些婆媳之间的规矩我们自然也是毫不知情，于是堂哥背着嫂子直接进了家门。然后按照预先的设定，一对新人喝了红枣莲子粥，喻示早生贵子，接着两个小男孩在大人的指导下蹦蹦跳跳上了床，这个习俗便就是所谓的“滚床”了。</p>
<p>十点半左右，我们出发前往举行婚礼的酒店。堂哥和嫂子，我还有伴娘，我们四个人便就在酒店的楼梯的台阶起始处迎接各路宾客。对于这样的场景，我确实是第一次，所有算是一点怯生吧，不过还好，老家这边的人还是挺随和的。一直到十二点，酒宴开始，司仪团队下来叫我们可以上楼准备婚礼了。</p>
<p>司仪是一个年轻小伙子，年龄与我们差不多，在他的主持之下，婚礼现场也是很有节奏感。一路按部就班的走下来，也是非常令人欢欣。让我印象有点深刻的是在改口茶环节，伯母的情绪异常激动，亲家母也很是激动，毕竟堂哥和嫂子的年纪也不算太小了。算一算，今年我都有28了，堂哥长我两岁，那是真真正正的奔三了的人啊。我因为一些特殊原因，至今没有成家，也算很是尴尬的事情。</p>
<p>席间，堂哥的表哥献唱了一首我也不知道名字的歌曲，唱的甚是贴合现场气氛。之后陪酒环节，我作为伴郎，跟着伴娘一起也是全程陪同堂哥和嫂子对所有宾客一一致敬。敬酒结束之后我应该是喝了许多酒的，于是接下来的事情我大多数都不记得了……</p>
<hr>
<p>嗯，堂哥的婚礼大概就描述到这里吧。</p>
<p>接下来是另一场重要的婚礼，即上面提到的，我表妹的婚礼。</p>
<p>重复的文字这里就不在赘述了，这里就说一下那段日记中间没有写完的场面吧。</p>
<p>婚礼现场定在靠近县政府的紫苑宾馆，场地应该是与前年表弟结婚的地方是一样的。请的司仪团队总体来说还算是过得去。婚车具体多少量我也给忘记了，应该是不下于十辆的吧。</p>
<p>由于是大年初四，这个日子，我也是翻了日历的，果不其然，是个绝佳的好日子。在迎亲的时候也碰到了许多其他的婚车队伍，就连我们扎花车的地方旁边，就有一个其他的婚车队伍。甚至，在紫苑宾馆的对面，便是另一对新人的婚礼现场。</p>
<p>整个婚礼流程也是按部就班形式的，基本上跟表弟的婚礼或者是堂哥的婚礼差不了多少。</p>
<p>开场节目表演是表弟携其妻子带来的一曲《美丽的神话》，不愧是科班出身，歌声一出惊艳四座。</p>
<hr>
<p>嗯，关于这两场的婚礼记录，就写这么多吧。</p>
<p>最近要开启提升团队能力的计划，具体的细节我需要思索一下，然后制定一个方案，届时也会在博客中公开发布。我虽然现在不是一个管理者，但我觉得团队中每个人都应该去思考这样的问题：如何去提升整个团队的作战水平。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/xovel/diary/blob/master/2017/01/2017-01-31-wedding.md" target="_blank" rel="noopener">2017-01-31-wedding.md</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在2017年的一月份，我以伴郎的身份分别出席了两场于我而言很重要的婚礼，很早以前我说过要对这个做一个详细的记录，今天特地前来重新回忆并描述一下，也算是对自己博客复苏计划的一个引子吧。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://xovel.cn/categories/life/"/>
    
    
      <category term="婚礼" scheme="https://xovel.cn/tags/%E5%A9%9A%E7%A4%BC/"/>
    
      <category term="记录" scheme="https://xovel.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="感想" scheme="https://xovel.cn/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>React or Vue: Which Javascript UI Library Should You Be Using?</title>
    <link href="https://xovel.cn/article/react-or-vue-which-javascript-ui-library-should-you-be-using.html"/>
    <id>https://xovel.cn/article/react-or-vue-which-javascript-ui-library-should-you-be-using.html</id>
    <published>2017-01-09T13:04:07.000Z</published>
    <updated>2017-01-09T14:10:22.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Source: <a href="https://medium.com/js-dojo/react-or-vue-which-javascript-ui-library-should-you-be-using-543a383608d" target="_blank" rel="noopener">React or Vue: Which Javascript UI Library Should You Be Using?</a><br>Translation: 未完成，敬请期待。</p>
</blockquote>
<p><img src="http://ww4.sinaimg.cn/large/79be2309gw1fbkp0222bkj20rs0b3gov.jpg" alt=""></p>
<p>In 2016 React cemented its position as king of the Javascript web frameworks. This year saw rapid growth of both its web and native mobile libraries, and a comfortable lead over main rival Angular.</p>
<p>But 2016 has been an equally impressive year for Vue. The release of its version 2 made a huge impression on the Javascript community, attested to by the 25,000 extra Github stars it gained this year.</p>
<p>The scope of both React and Vue is undeniably similar: both are lightweight component-based libraries for building user interfaces that focus on the view layer only. Both can be used in a simple project, or be scaled up to a sophisticated app using cutting edge tooling.</p>
<p>As a result, a lot of web developers are wondering which one they should be using. Is one clearly superior over the other? Do they have specific pros and cons to be aware of? Or are they basically the same?</p>
<p><strong>Two frameworks, two advocates.</strong></p>
<p>In this article I want to answer those questions with a thorough and fair comparison. The only problem is: I’m an unashamed Vue fan-boy and totally biased. I’ve used Vue heavily in my projects this year, sung its praises here on Medium and even released a <a href="https://www.udemy.com/vuejs-2-essentials" target="_blank" rel="noopener">Udemy course</a>.</p>
<p>To even out my biased position I’ve bought in my friend Alexis Mangin who is both a great Javascript developer and a big React fan. He’s similarly immersed in React, using it frequently in both web and mobile projects.</p>
<p>Alexis asked me one day: “why are you so into Vue, and not React?” Since I didn’t know React that well, I couldn’t give a good answer. So I put the idea to him that we sit down one day with our laptops and show each other what our chosen library had to offer.</p>
<p><img src="http://ww2.sinaimg.cn/large/79be2309gw1fbkp00ztjzj20m80e2414.jpg" alt=""></p>
<blockquote>
<p>Anthony (left) and Alexis (right) comparing React and Vue at Bull and Bear Cafe in Chiang Mai, Thailand</p>
</blockquote>
<p>After a lot of discussion and learning from both sides, the following six points are our key findings.</p>
<p><strong>If you like building apps with templates (or want the option to), go with Vue.</strong></p>
<p>Putting your markup in an HTML file is the default option for a Vue app. Similar to Angular, moustache braces are used for data-binding expressions, while directives (special HTML attributes) are used for adding functionality to the template.</p>
<p>The follow demonstrates a simple Vue app. It prints a message and has a button that dynamically reverses the message:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// JS</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello Vue.js!</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: function () &#123;</span><br><span class="line">      this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>In contrast, React apps shun templates and require the developer to create their DOM in Javascript, typically aided with JSX. Below is the same simple app implemented with React:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// JS (pre-transpilation)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      message: <span class="string">'Hello React.js!'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  reverseMessage() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; </span><br><span class="line">      message: <span class="keyword">this</span>.state.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.state.message&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.reverseMessage()&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Reverse Message</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(App, document.getElementById('app'));</span></span><br></pre></td></tr></table></figure>
<p>Templates are easier to understand for newer developers who’ve come from the standard web development paradigm. But even some experienced developers prefer them as templates can better seperate layout from functionality and give the option of using pre-processors like Pug.</p>
<p>But templates come at the cost of having to learn all the extended HTML syntax, while render functions only require knowledge of standard HTML and Javascript. Render functions also benefit from easier debugging and testing.</p>
<p>On this point, though, you can’t go wrong with Vue, as it’s introduced the option of using either templates or render functions in version 2.</p>
<p><strong>If you like simplicity and things that “just work”, go with Vue.</strong></p>
<p>A simple Vue project can be run directly from a browser with no need of transpilation. This allows Vue to be easily dropped into a project the way jQuery is.</p>
<p>While this is also technically possible with React, typical React code leans more heavily on JSX and on ES6 features like classes and non-mutating array methods.</p>
<p>But Vue’s simplicity runs more deeply in its design. Let’s compare how the two libraries handle application data (i.e. “state”).</p>
<p>State in React is immutable so you can’t directly change it. You need to use the setState API method:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123; </span><br><span class="line">    message: <span class="keyword">this</span>.state.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Diff’ing the current and previous state is how React knows when and what to re-render in the DOM, hence the need for immutable state.<br>In contrast, data is just mutated in Vue. The same data property can be altered far less verbosely in Vue:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that data properties are available as properties of </span></span><br><span class="line"><span class="comment">// the Vue instance</span></span><br><span class="line"><span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>
<p>Before you conclude that Vue’s rendering system must lack the efficiency of React’s, let’s examine how state in Vue is managed under the hood: when you add a new object to the state, Vue will walk through all of its properties and convert them to getter and setters. Vue’s reactivity system now keeps track of the state and will automatically re-render the DOM when it is mutated.</p>
<p>Impressively, altering state in Vue is not only more succinct, but its re-rendering system is actually faster and more efficient than React’s.</p>
<p>Vue’s reactivity system does have caveats, though. For example, it cannot detect property addition or deletion and certain array changes. These cases can be worked around with a React-like set method from the Vue API.</p>
<p><strong>If you need your application to be as small and fast as possible, go with Vue.</strong></p>
<p>Both React and Vue will build a virtual DOM and synchronise the real DOM when the app’s state changes. Both have their own means of optimising this process.</p>
<p>Vue core developers have offered a benchmark test that shows Vue’s rendering system to be faster than React’s. In this test a list of 10,000 items are rendered 100 times. The comparison is tabled below.</p>
<p><img src="http://ww3.sinaimg.cn/large/79be2309gw1fbkp019rknj20m808dglu.jpg" alt=""></p>
<blockquote>
<p>Benchmarks as published on vuejs.org</p>
</blockquote>
<p>From a pragmatic standpoint, this kind of benchmark is only relevant in edge cases. Most apps will not need to do this kind of operation routinely so it should generally not be considered an important point of comparison.</p>
<p>Page size, though, is relevant to all projects, and again Vue has the upper hand. Minified, the current release of the Vue library is only 25.6KB.</p>
<p>To get a similar set of functionality in React you need React DOM (37.4KB) and the React with Addons library (11.4KB), which totals 48.8KB, almost double the size of Vue. To be fair you will get a larger API with React, but you don’t get double as much functionality.</p>
<p><strong>If you plan to build a large scale app, go with React.</strong></p>
<p>A comparison of a simple app implemented in both Vue and React, like the one at the beginning of this article, may initially bias a developer to favour Vue. This is because template-based apps are easier to understand at first look, and quicker to get up and running with.</p>
<p>But these initial benefits introduce technical debt that can slow development of apps reaching a larger scale. Templates are prone to unnoticed runtime errors, are hard to test, and are not easy to restructure or decompose.</p>
<p>In contrast, Javascript-made templates can be organised into components with nicely decomposed and DRY code that is more reusable and testable.</p>
<p>Vue also has a component system and render functions. But React’s rendering system is more configurable and has features like shallow rendering that, combined with React’s testing utilities, allow for far more testable and maintainable code.</p>
<p>Meanwhile, React’s immutable application data may not be as succinct, but it shines in larger application when transparency and testability become critical.</p>
<p><strong>If you want a library that is adaptable for both web and native apps, go with React.</strong></p>
<p>React Native is a library for building native mobile applications with Javascript. It’s the same as React.js, only instead of using web components, it uses native components. If you’ve learnt React.js, you’ll very easily be able to pick up React Native, and vice versa.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>; </span><br><span class="line"><span class="keyword">import</span> &#123; AppRegistry, Text, View &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;   </span><br><span class="line">  render() &#123;     </span><br><span class="line">    <span class="keyword">return</span> (       </span><br><span class="line">      &lt;View&gt;         </span><br><span class="line">        &lt;Text&gt;Hello, React Native!<span class="xml"><span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );   </span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">AppRegistry.registerComponent('HelloWorld', () =&gt; HelloWorld);</span></span><br></pre></td></tr></table></figure>
<p>The significance is that a developer can build an app on either the web or native mobile without requiring a different set of knowledge and tools. Learning React gives you a huge bang for you buck if you intend to develop for both web and mobile.</p>
<p>Alibaba’s Weex is another cross-platform UI project. Currently it considers Vue an “inspiration” and uses a lot of the same syntax, with plans to fully integrate Vue. However, the timeline and specifics of this integration are still unclear.</p>
<p>Since Vue has HTML templates as a core part of its design and does not have custom rendering as a current feature, it’s hard to see that a native counterpart for Vue.js in its current form will be as tight as what React.js and React Native are.</p>
<p><strong>If you want the biggest ecosystem, go with React.</strong></p>
<p>There’s no question that React is currently the more popular library with ~2.5M NPM downloads a month as opposed to Vue’s ~225K per month.</p>
<p><img src="http://ww1.sinaimg.cn/large/79be2309gw1fbkp01iettj20m8092mxp.jpg" alt=""></p>
<p>Popularity is not merely a shallow benefit. It means there are more articles, tutorials and Stack Overflow answers for help. It means there are more tools and add-ons to leverage in a project and save developers from building everything themselves.</p>
<p>Both libraries are open source, but React was born from Facebook and benefits from that patronage. Developers and companies committing to React can be assured of continued maintenance.</p>
<p>In contrast, Vue was created by a single developer, Evan You, and You is currently the only full time maintainer of Vue. Vue has some corporate sponsorship but not on the scale of Facebook or Google.</p>
<p>To the credit of the Vue team, its small size and independence has not materialised as a disadvantage. Vue has a regular release cycle and even more impressively, Vue has only 54 open issues on Github compared to 3456 closed issues, while React has a far larger 530 open issues compared to 3447 closed.</p>
<p><strong>If you’re already happy with one or the other, there’s no need to switch.</strong></p>
<p>To recap, our findings, Vue’s strengths are:</p>
<ul>
<li>Flexible options for template or render functions</li><li>Simplicity in syntax and project setup</li><li>Faster rendering and smaller size</li></ul>
<p>React’s strengths:</p>
<ul>
<li>Better at scale, studier and more testable</li><li>Web and native apps</li><li>Bigger ecosystem with more support and tools available</li></ul>
<p>However, both React and Vue are exceptional UI libraries and have more similarities than differences. Most of their best features are shared:</p>
<ul>
<li>Fast rendering with virtual DOM</li><li>Lightweight</li><li>Reactive components</li><li>Server-side rendering</li><li>Easy integration with router, bundler and state management</li><li>Great support and community</li></ul>
<p>If you think we’ve missed something we’d love to hear in the comments. Happy developing!</p>
<hr>
<p><em>About the authors</em></p>
<p>Anthony Gore</p>
<blockquote>
<p>I’m a Javascript developer and online course instructor. My latest course is Vue.js 2 Essentials: Build Your First Vue App, available on Udemy.</p>
</blockquote>
<p>Alexis Mangin</p>
<blockquote>
<p>Alexis helped me write this article with his exceptional knowledge of web development. You should follow him on Medium as he writes his own great tutorials on React.</p>
</blockquote>
<hr>
<p>Vue的作者<a href="https://medium.com/@youyuxi/pretty-good-comparison-overall-but-a-few-points-id-like-to-discuss-e4f6460e75d5#.mij64qy5y" target="_blank" rel="noopener">回复了该文</a>，摘录如下：<br>Pretty good comparison overall, but a few points I’d like to discuss:</p>
<blockquote>
<p>“Templates are prone to unnoticed runtime errors, are hard to test, and are not easy to restructure or decompose.”</p>
</blockquote>
<p>These arguments against templates are too broad. Templates are by definition statically analyzable (even more so than dynamic render functions) and Vue provides many compile-time AND runtime warnings for common template syntax errors, and can be further improved in the future. Also, since Vue templates compile into render functions under the hood, a template containing expression syntax errors will be detected at compile time instead of runtime (if you are using a build setup instead of in-browser compilation).</p>
<blockquote>
<p>“In contrast, Javascript-made templates can be organised into components with nicely decomposed and DRY code that is more reusable and testable.”</p>
</blockquote>
<p>Organizing your application as decoupled components has little to do with whether you are using templates or JSX, but more with how components are defined as a function of state and prop. In this sense, Vue components and React components are equivalent on the higher level and there’s nothing that makes a React component fundamentally more testable than a Vue component. You can do exactly the same thing with a Vue component: render the virtual DOM with different set of props and assert the output. Admittedly this is may not be very obvious for new users, but we are planning to provide official component testing utilities in the near future.</p>
<blockquote>
<p>“Meanwhile, React’s immutable application data may not be as succinct, but it shines in larger application when transparency and testability become critical.”</p>
</blockquote>
<p>This statement lacks the proper context of state management patterns used. In most cases, the built-in state management patterns provided by the frameworks themselves are insufficient for large scale apps, and a dedicated solution like Redux or Vuex must be used. It is very premature to declare that “If you plan to build a large scale app, go with React” without giving a proper discussion about the solutions designed to deal with large scale apps for both frameworks.</p>
<blockquote>
<p>Alibaba’s Weex is another cross-platform UI project. Currently it considers Vue an “inspiration” and uses a lot of the same syntax, with plans to fully integrate Vue. However, the timeline and specifics of this integration are still unclear.</p>
</blockquote>
<p>The <a href="https://github.com/weexteam/weex-vue-framework/issues/9" target="_blank" rel="noopener">roadmap</a> is publicly available. In the latest Weex release (0.9.4), Vue 2 is now already officially integrated as a runtime framework which allows the use of the majority of features found in Vue’s API (excluding those that are web-platform-specific). (<a href="https://github.com/alibaba/weex/tree/dev/examples/vue" target="_blank" rel="noopener">examples</a>)</p>
<blockquote>
<p>“Since Vue has HTML templates as a core part of its design and does not have custom rendering as a current feature, it’s hard to see that a native counterpart for Vue.js in its current form will be as tight as what React.js and React Native are.”</p>
</blockquote>
<p>This is factually wrong. Vue 2.x is designed to support <a href="https://github.com/vuejs/vue/tree/dev/src/platforms" target="_blank" rel="noopener">custom rendering targets</a> from the very beginning, it’s just not exposed via public APIs. Again, templates are compiled into Virtual DOM render functions which allows any type of lower-level customizations needed to adapt to native rendering targets.</p>
]]></content>
    
    <summary type="html">
    
      本文为英文文章《React or Vue: Which Javascript UI Library Should You Be Using?》的原文，并附带有作者介绍和Vue.js的作者的亲自回复。文章主要讲述了React和Vue之间的差异性。
    
    </summary>
    
      <category term="翻译" scheme="https://xovel.cn/categories/translate/"/>
    
    
      <category term="javascript" scheme="https://xovel.cn/tags/javascript/"/>
    
      <category term="react" scheme="https://xovel.cn/tags/react/"/>
    
      <category term="vue" scheme="https://xovel.cn/tags/vue/"/>
    
      <category term="ui" scheme="https://xovel.cn/tags/ui/"/>
    
      <category term="programming" scheme="https://xovel.cn/tags/programming/"/>
    
      <category term="web" scheme="https://xovel.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2016年总结</title>
    <link href="https://xovel.cn/article/summary-2016.html"/>
    <id>https://xovel.cn/article/summary-2016.html</id>
    <published>2016-12-31T13:01:29.000Z</published>
    <updated>2018-01-01T09:09:20.956Z</updated>
    
    <content type="html"><![CDATA[<p>转眼已经是2016年的最后一天了，是时候来好好做一个全面的总结了。</p>
<p>那么，直接进入主题吧！</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>年初，去往冷水滩的医院总部，参加了一个不大不小的会议，老板给大家讲述了宏大的愿景。那个时候的我依然是充满激情的，就如同此时此刻的我。2月份回到长沙后，因为各方面的原因，参与投资的项目的局势已然不容乐观。无论我怎么挣扎挽回，也无法避免项目的失败，期间的缘由这里就不详述了。</p>
<p>投资失利的我，于4月初正式离开了华懿集团。在4月中下旬，去往宇成集团上班。直到上个月18号，因不可抗力，被迫离开公司。休整了一段时间之后，目前在梅溪湖一家从事教育装备系统管理的公司上班，负责装备系统的前端建设。</p>
<p>9月22日前后，去深圳出差，这一次的出差很可能已经改变了我的人生轨迹，相关的记录本博客也有文章进行记录。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>2016年，发生了很多有意思的事情。生活上，一切也变得越来越好。年初自己的茫然失措，到现如今的悠然自得，自己能够很清楚的感受到自己的变化。正如期望中的一样，努力变成一个内心波澜不惊的人将会是我长久的状态。</p>
<p>虽然投资失利带来的短期内的负面效应，给我造成了很多不好的影响。失败并不可怕，可怕的是没有面对失败的勇气和战胜挫折的魄力。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>2016年技术栈的提升，没有以往的高。当然，一直以来都没有多少提升。</p>
<p>2016年主要攻坚的技术依然是前端WEB方面的，核心就是JS编程。</p>
<p>在宇成工作的期间，JS编程倒并没有进行多少，主要是一些HTML和CSS的编写。自己想要晋升的技术栈，诸如<code>React</code>、<code>Angular</code>等，也只是略识皮毛。不过相对之前在福建自己对这些方面的技术的认知，已经提升了不少层次。</p>
<p>对于JS的运用，可以说依然是有一个大幅度的提升，自己对命令行执行JS的理解，深入了不少，并且使用一款基于<code>Node.js</code>的博客构建工具<code>hexo</code>，搭建了个人博客。就是本博客。到目前为止，共计写博文47篇，不包含本篇。另有几个页面放置在特殊目录<code>花园/竹林</code>里面。</p>
<p>APP方面的学习，目前主要是WebApp的方式，也就是我目前做的前端方式。但这种技术方式，并不是我所赞同的方式。这个想法以后有机会再详表吧。</p>
<p>9月份，微信抛出了小程序的概念，当时的自己，及时跟进，熟悉了大部分微信小程序的文档。</p>
<h4 id="花园-竹林"><a href="#花园-竹林" class="headerlink" title="花园/竹林"></a><a href="http://xovel.cn/garden/">花园/竹林</a></h4><p>具体的链接就不贴了，可以自行查看。</p>
<ol>
<li>宇成朝阳广场页面</li><li>图片转Base64编码工具</li><li>风华60年投票活动分类入口</li><li>一个错视的旋转动画</li><li>一个自适应菜单导航页面</li><li>移动端下拉刷新操作</li><li>Less在线编写</li></ol>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>2016年接手的项目不算太多。</p>
<p>除去去年年末给华懿集团重新架设的官网，其他外围的项目我并没有直接进行参与。在宇成集团负责的主要项目有两个，一个是<code>奢厨生鲜</code>，另一个的是<code>狂乐传媒</code>。两者均主要为移动端进行建设，所以在进行响应式设计的时候主要考虑主流手机的界面的前端展现。前后端分离的方式，给自己的工作带来了一定程度的改变。</p>
<h4 id="奢厨生鲜"><a href="#奢厨生鲜" class="headerlink" title="奢厨生鲜"></a>奢厨生鲜</h4><p>该项目为公司向互联网发展的核心项目之一，前端主程便是我，负责所有页面的静态实现，同时协作完成与后台数据的对接。</p>
<h4 id="狂乐传媒"><a href="#狂乐传媒" class="headerlink" title="狂乐传媒"></a>狂乐传媒</h4><p>该项目为公司向传媒进军的项目，当时并不是核心项目，所以我只负责了静态页面的实现。后来由于项目负责人的离开，此项目也就不了了之了。</p>
<blockquote>
<p>关于这两个项目更多的信息，鉴于职业操守和保密规则，如果有兴趣，可以单独与我沟通了解。</p>
</blockquote>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>自己是一个比较喜欢阅读与写作的人，不过说来惭愧，在2016年，自己的阅读量并不是太多。在读书馆借了不少书，但能够通读的并不多。所以，这个数据就不做展现了。</p>
<h3 id="圣血记"><a href="#圣血记" class="headerlink" title="圣血记"></a>圣血记</h3><p>本来这一块的子标题应该是<strong>写作</strong>，但是关于博客的写作上面已经提及了，于是，关于写作方面，值得进行记录的就是<code>圣血记</code>了。</p>
<p>2016年，所创作的剧情隶属于《圣血记》第二部《寻玉》。今年发表的篇章共计26，其中《寻玉》21篇。</p>
<p>关于具体的剧情进展，这里不做展开了。要提一下的是今年的下半年，基本上没有进行新剧情的创作。</p>
<h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p>已架设在<code>GitHub</code>上的开源项目：</p>
<h4 id="CanvasBubble"><a href="#CanvasBubble" class="headerlink" title="CanvasBubble"></a><a href="https://github.com/xovel/CanvasBubble" target="_blank" rel="noopener">CanvasBubble</a></h4><p>使用canvas实现的一个泡泡背景。</p>
<h4 id="Carousel3D"><a href="#Carousel3D" class="headerlink" title="Carousel3D"></a><a href="https://github.com/xovel/Carousel3D" target="_blank" rel="noopener">Carousel3D</a></h4><p>一款3D旋转效果的小工具。</p>
<h4 id="PullRefresh"><a href="#PullRefresh" class="headerlink" title="PullRefresh"></a><a href="https://github.com/xovel/PullRefresh" target="_blank" rel="noopener">PullRefresh</a></h4><p>JS实现的下拉刷新插件。</p>
<h4 id="octoverse"><a href="#octoverse" class="headerlink" title="octoverse"></a><a href="https://github.com/xovel/octoverse" target="_blank" rel="noopener">octoverse</a></h4><p>GitHub上的关于2016总结页面的离线版本。</p>
<hr>
<p>罢了，罢了，总结就这样吧。</p>
]]></content>
    
    <summary type="html">
    
      2016年年末大总结。
    
    </summary>
    
      <category term="生活" scheme="https://xovel.cn/categories/life/"/>
    
    
      <category term="2016" scheme="https://xovel.cn/tags/2016/"/>
    
      <category term="2017" scheme="https://xovel.cn/tags/2017/"/>
    
      <category term="总结" scheme="https://xovel.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="经历" scheme="https://xovel.cn/tags/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
</feed>
